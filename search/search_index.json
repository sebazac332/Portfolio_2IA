{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Impress\u00f5es gerais","text":""},{"location":"#portfolio-2","title":"Portf\u00f3lio 2","text":"<p>Esta parte do curso \u00e9 especificamente problemas de busca e como estes s\u00e3o classificados, al\u00e9m disso, os agentes especializados em sua resolu\u00e7\u00e3o e os algoritmos que eles usam. Dentro desses algoritmos est\u00e3o os algoritmos de busca, algoritmos de busca em ambientes complexos e algoritmos gen\u00e9ticos, com a informa\u00e7\u00e3o apresentada nesta parte voc\u00ea pode saber como eles funcionam, quais s\u00e3o seus pontos fortes e fracos, quais s\u00e3o as heur\u00edsticas que afetam seu comportamento e em quais situa\u00e7\u00f5es eles s\u00e3o melhor utilizados. Toda essa informa\u00e7\u00e3o nos permite identificar com seguran\u00e7a o tipo de problema que enfrentamos, quais s\u00e3o suas caracter\u00edsticas, qual heur\u00edstica se ajusta melhor e qual algoritmo devemos usar para uma resolu\u00e7\u00e3o satisfat\u00f3ria.</p> <p>In\u00edcio do portf\u00f3lio 2</p>"},{"location":"#portfolio-3","title":"Portf\u00f3lio 3","text":"<p>Nesta parte do curso se v\u00ea informa\u00e7\u00f5es sobre um tipo diferente de problema, um que tem maiores requisitos de satisfa\u00e7\u00e3o, estes s\u00e3o os problemas de satisfa\u00e7\u00e3o de condi\u00e7\u00f5es, para esses problemas n\u00e3o \u00e9 suficiente apenas chegar a uma solu\u00e7\u00e3o, mas condi\u00e7\u00f5es extras devem ser atendidas. Para isso, veja que tipos de condi\u00e7\u00f5es existem, as classes de consist\u00eancia necess\u00e1rias para cumprir essas condi\u00e7\u00f5es e os tipos de algoritmos que podem ser usados nesses problemas. Com esta informa\u00e7\u00e3o, j\u00e1 somos capazes de resolver problemas um pouco mais complexos.</p> <p>In\u00edcio do portf\u00f3lio 3</p>"},{"location":"CSP_algorithms/","title":"Algoritmos de satisfa\u00e7\u00e3o de condi\u00e7\u00f5es","text":""},{"location":"CSP_algorithms/#algoritmo-ac-3","title":"Algoritmo AC-3","text":"<p>O algoritmo mais popular para refor\u00e7ar a consist\u00eancia do arco \u00e9 chamado AC-3. Para tornar cada vari\u00e1vel consistente com o arco, o algoritmo AC-3 mant\u00e9m uma fila de arcos a serem considerados. Inicialmente, a fila cont\u00e9m todos os arcos do CSP. (Cada restri\u00e7\u00e3o bin\u00e1ria se transforma em dois arcos, um em cada dire\u00e7\u00e3o.) Em seguida, o AC-3 retira um arco arbitr\u00e1rio (Xi,Xj) da fila e torna Xi consistente com o arco em rela\u00e7\u00e3o a Xj. Se isso deixar Di inalterado, o algoritmo simplesmente passa para o pr\u00f3ximo arco. Mas se isso revisar Di (tornar o dom\u00ednio menor), adicionaremos \u00e0 fila todos os arcos (Xk,Xi) em que Xk \u00e9 um vizinho de Xi. Precisamos fazer isso porque a altera\u00e7\u00e3o em Di pode permitir mais redu\u00e7\u00f5es em Dk, mesmo que tenhamos considerado Xk anteriormente. Se Di for revisado para zero, saberemos que todo o CSP n\u00e3o tem solu\u00e7\u00e3o consistente e o AC-3 pode retornar imediatamente uma falha. Caso contr\u00e1rio, continuaremos a verifica\u00e7\u00e3o, tentando remover valores dos dom\u00ednios das vari\u00e1veis at\u00e9 que n\u00e3o haja mais arcos na fila. [1]</p>"},{"location":"CSP_algorithms/#algoritmo-de-retrocesso","title":"Algoritmo de retrocesso","text":"<p>O algoritmo de backtracking \u00e9 um m\u00e9todo de busca em profundidade usado para explorar sistematicamente as poss\u00edveis solu\u00e7\u00f5es em CSPs. Ele opera atribuindo valores a vari\u00e1veis e retrocede se alguma atribui\u00e7\u00e3o violar uma restri\u00e7\u00e3o. [5]</p> <p>Funcionamento:</p> <ul> <li>O algoritmo seleciona uma vari\u00e1vel e atribui a ela um valor. [5]</li> <li>Ele atribui valores recursivamente \u00e0s vari\u00e1veis subsequentes. [5]</li> <li>Se surgir um conflito (ou seja, n\u00e3o for poss\u00edvel atribuir um valor v\u00e1lido a uma vari\u00e1vel), o algoritmo volta \u00e0 vari\u00e1vel anterior e tenta um valor diferente. [5]</li> <li>O processo continua at\u00e9 que uma solu\u00e7\u00e3o v\u00e1lida seja encontrada ou todas as possibilidades tenham sido esgotadas. [5]</li> </ul> <p>Esse m\u00e9todo \u00e9 amplamente usado devido \u00e0 sua simplicidade, mas pode ser ineficiente para problemas grandes com muitas vari\u00e1veis. [5]</p>"},{"location":"CSP_algorithms/#algoritmo-de-verificacao-progressiva","title":"Algoritmo de verifica\u00e7\u00e3o progressiva","text":"<p>O algoritmo de verifica\u00e7\u00e3o de avan\u00e7o \u00e9 um aprimoramento do algoritmo de retrocesso que visa reduzir o espa\u00e7o de pesquisa aplicando verifica\u00e7\u00f5es de consist\u00eancia local. [5]</p> <p>Funcionamento:</p> <ul> <li>Para cada vari\u00e1vel n\u00e3o atribu\u00edda, o algoritmo mant\u00e9m o controle dos valores v\u00e1lidos restantes. [5]</li> <li>Quando um valor \u00e9 atribu\u00eddo a uma vari\u00e1vel, as restri\u00e7\u00f5es locais s\u00e3o aplicadas \u00e0s vari\u00e1veis vizinhas, eliminando os valores inconsistentes de seus dom\u00ednios. [5]</li> <li>Se um vizinho n\u00e3o tiver mais valores v\u00e1lidos ap\u00f3s a verifica\u00e7\u00e3o de encaminhamento, o algoritmo retrocede. [5]</li> </ul> <p>Esse m\u00e9todo \u00e9 mais eficiente do que o backtracking puro porque evita alguns conflitos antes que eles ocorram, reduzindo c\u00e1lculos desnecess\u00e1rios. [5]</p>"},{"location":"CSP_algorithms/#algoritmos-de-propagacao-de-restricoes","title":"Algoritmos de propaga\u00e7\u00e3o de restri\u00e7\u00f5es","text":"<p>Os algoritmos de propaga\u00e7\u00e3o de restri\u00e7\u00f5es reduzem ainda mais o espa\u00e7o de pesquisa ao impor a consist\u00eancia local em todas as vari\u00e1veis. [5]</p> <p>Funcionamento:</p> <ul> <li>As restri\u00e7\u00f5es s\u00e3o propagadas entre vari\u00e1veis relacionadas. [5]</li> <li>Os valores inconsistentes s\u00e3o eliminados dos dom\u00ednios das vari\u00e1veis, aproveitando as informa\u00e7\u00f5es obtidas de outras vari\u00e1veis. [5]</li> <li>Esses algoritmos refinam o espa\u00e7o de pesquisa fazendo infer\u00eancias, removendo valores que levariam a conflitos. [5]</li> </ul> <p>A propaga\u00e7\u00e3o de restri\u00e7\u00f5es \u00e9 comumente usada em conjunto com outros algoritmos de CSP, como o backtracking, para aumentar a efici\u00eancia ao restringir o espa\u00e7o de solu\u00e7\u00e3o no in\u00edcio do processo de pesquisa. [5]</p>"},{"location":"CSP_algorithms/#exemplo-de-implementacao-de-algoritmos-de-satisfacao-de-condicoes","title":"Exemplo de implementa\u00e7\u00e3o de algoritmos de satisfa\u00e7\u00e3o de condi\u00e7\u00f5es","text":"<p>Exemplo de algoritmo de backtraking em que se tenta resolver um labirinto, no qual est\u00e1 presa uma ratazana. Este labirinto \u00e9 representado por uma matriz de tamanho n x n onde 1 s\u00e3o espa\u00e7os onde o rato pode passar e 0 s\u00e3o espa\u00e7os bloqueados. O rato \u00e9 colocado na posi\u00e7\u00e3o (0, 0) e deve chegar \u00e0 posi\u00e7\u00e3o (n-1, n-1). No caso de o rato acabar em uma posi\u00e7\u00e3o sem sa\u00edda, ele deve ser capaz de voltar e tentar outro caminho.</p> <pre><code>\nclass Solution:\n    def findPath(self, mat):\n\n        n = len(mat)\n        visited = set()\n        paths = []\n\n        def dfs(row, col, path):\n            if (row == n-1) and (col==n-1):\n                paths.append(''.join(path))\n                return\n\n            if row &lt; 0 or row &gt;= n or col &lt; 0 or col &gt;= n or mat[row][col] != 1 or (row, col) in visited:\n                return\n\n            visited.add((row, col))\n\n            dfs(row + 1, col, path + ['D']) \n            dfs(row, col - 1, path + ['L']) \n            dfs(row - 1, col, path + ['U'])\n            dfs(row, col + 1, path + ['R']) \n\n\n            visited.remove((row, col))\n\n        dfs(0,0,[])\n        return sorted(paths)\n\nsolution = Solution()\nmatrix = [\n    [1, 0, 0, 0],\n    [1, 1, 0, 1],\n    [0, 1, 1, 1],\n    [0, 0, 0, 1]\n]\nresult = solution.findPath(matrix)\nprint(result)\n\n</code></pre>"},{"location":"atomic_vs_factored/","title":"Representa\u00e7\u00e3o At\u00f4mica vs. Fatorada","text":"<p>As representa\u00e7\u00f5es s\u00e3o categorizadas em um eixo de complexidade e capacidade expressiva onde a representa\u00e7\u00e3o at\u00f4mica \u00e9 a menos complexa e tamb\u00e9m menos expressiva, seguida por representa\u00e7\u00e3o fatorial e finalmente representa\u00e7\u00e3o estruturada. [4]</p>"},{"location":"atomic_vs_factored/#representacao-atomica","title":"Representa\u00e7\u00e3o At\u00f4mica","text":"<p>Cada estado do mundo pode ser considerado como uma caixa preta que n\u00e3o tem estrutura interna, sabe-se qual \u00e9 o estado mas n\u00e3o os elementos que cont\u00e9m. Um exemplo seria tentar tra\u00e7ar uma rota entre duas cidades, em uma representa\u00e7\u00e3o at\u00f4mica s\u00f3 se sabe o nome da cidade onde estamos atualmente. [1]</p> <p>Usada em:</p> <ul> <li>Algoritmos de busca [3]</li> <li>Processos de decis\u00e3o de Markov [2]</li> <li>Modelos ocultos de Markov [2]</li> <li>Tarefas de percep\u00e7\u00e3o b\u00e1sica [3]</li> </ul> <p></p> <p>Representa\u00e7\u00e3o at\u00f3mica.</p>"},{"location":"atomic_vs_factored/#representacao-fatorada","title":"Representa\u00e7\u00e3o Fatorada","text":"<p>Estados s\u00e3o divididos em atributos e vari\u00e1veis que t\u00eam um valor, descrevem um problema com uma fidelidade mais alta, no entanto a estrutura interna desses atributos e vari\u00e1veis est\u00e1 oculta. Enquanto dois estados at\u00f4micos n\u00e3o t\u00eam nada em comum, pois s\u00e3o caixas pretas, dois estados fatorados podem ter alguns atributos compartilhados, o que ajuda a ver com maior clareza quais a\u00e7\u00f5es devem ser realizadas para converter um estado em outro. Um exemplo disso \u00e9 revisitar o problema da rota entre duas cidades, em representa\u00e7\u00e3o fatorada pode levar em conta coisas como os gps cordenadas, a quantidade de combust\u00edvel ou o estado do motor na cidade atual. [1]</p> <p>Usada em:</p> <ul> <li>Algoritmos de satisfa\u00e7\u00e3o de restri\u00e7\u00f5es [2]</li> <li>Redes bayesianas [2]</li> </ul> <p></p> <p>Representa\u00e7\u00e3o fatorada.</p>"},{"location":"complex_search/","title":"Busca em ambientes complexos","text":""},{"location":"complex_search/#busca-local","title":"Busca local","text":"<p>S\u00e3o usados em problemas onde o caminho para a solu\u00e7\u00e3o n\u00e3o importa, apenas o estado objetivo \u00e9 importante. Eles buscam come\u00e7ando de um estado inicial para seus vizinhos sem guardar o caminho percorrido ou os estados alcan\u00e7ados, isso significa que n\u00e3o s\u00e3o sistem\u00e1ticos pois existe a probabilidade de nunca explorarem a por\u00e7\u00e3o do espa\u00e7o de busca onde est\u00e1 a solu\u00e7\u00e3o. Tem duas vantagens principais, usam pouca mem\u00f3ria e podem encontrar solu\u00e7\u00f5es razo\u00e1veis em espa\u00e7os infinitos onde algoritmos sistem\u00e1ticos n\u00e3o funcionam. [12]</p>"},{"location":"complex_search/#escalada","title":"Escalada","text":"<p>Algoritmo que se baseia em escolher sempre o estado que tem maior ou menor valor dependendo do que \u00e9 necess\u00e1rio, isto faz-o mantendo um registo de um estado espec\u00edfico e em cada itera\u00e7\u00e3o movendo-se a um vizinho deste estado que possua o maior/menor valor. A execu\u00e7\u00e3o termina quando n\u00e3o \u00e9 poss\u00edvel encontrar um estado com um valor maior/menor que o acutual. Este algoritmo n\u00e3o \u00e9 capaz de olhar mais al\u00e9m dos vizinhos do estado atual. [5]</p> <p>Existem algumas situa\u00e7\u00f5es em que este algoritmo fica preso, estes s\u00e3o:</p> <ul> <li>Local maxima: Estado que possui um valor maior do que todos os seus vizinhos, mas menor do que o valor m\u00e1ximo global. [5]</li> <li>Cristas: Sequ\u00eancia de local maxima que \u00e9 muito dif\u00edcil navegar para o algoritmo. [5]</li> <li>Planaltos: \u00c1rea completamente plana no espa\u00e7o de busca, onde n\u00e3o h\u00e1 valores maiores ou menores, pode ser de dois tipos local m\u00e1ximo plano onde n\u00e3o h\u00e1 forma de prosegir ou um ombro, em que eventualmente se pode conseguir sair e continuar com a busca. [5]</li> </ul>"},{"location":"complex_search/#variacoes-de-escalada","title":"Varia\u00e7\u00f5es de Escalada","text":"<ul> <li>Escalada estoc\u00e1stica: Escolhe aleatoriamente entre os movimentos de subida. [12]</li> <li>Escalada em colina de primeira escolha: Implementa o hill climbing estoc\u00e1stico gerando sucessores aleatoriamente at\u00e9 que seja gerado um que seja melhor do que o estado atual. [12]</li> <li>Escalada em colina com rein\u00edcio aleat\u00f3rio: Realiza uma s\u00e9rie de pesquisas de hill climbing a partir de estados iniciais gerados aleatoriamente, at\u00e9 que um objetivo seja encontrado. [12]</li> </ul>"},{"location":"complex_search/#recozimento-simulado","title":"Recozimento simulado","text":"<p>Uma das fraquezas do algoritmo de escalada \u00e9 que ele nunca se mover\u00e1 para um estado que tenha um valor menor/maior mesmo que este seja um movimento necess\u00e1rio para obter o melhor resultado, para lidar com essa fraqueza pode combinar o algoritmo de escalada com uma funcionalidade de aleatoriedade resultando no algoritmo de Recozimento simulado. Neste algoritmo n\u00e3o se escolhe o melhor estado imediatamente, mas um movimento aleat\u00f3rio \u00e9 realizado, se este melhora a situa\u00e7\u00e3o (valor maior/menor que o atual) sempre se escolhe, caso contr\u00e1rio o algoritmo aceitar\u00e1 o movimento com uma probabilidade menor a um, isto ir\u00e1 diminuir dependendo de tanto este movimento piora a situa\u00e7\u00e3o e segundo uma vari\u00e1vel conhecida como temperatura (T), que come\u00e7a com um valor alto e vai diminuindo ao longo do tempo, quanto maior o valor de T mais prov\u00e1vel \u00e9 que se escolha movimentos \"ruins\". [5]</p>"},{"location":"complex_search/#busca-de-feixe-local","title":"Busca de feixe local","text":"<p>Busca local onde em vez de manter um estado, mant\u00e9m k estados simultaneamente. Preenche-se com k estados gerados aleatoriamente e por cada passo s\u00e3o gerados todos os sucessores de todos os estados, se entre eles estiver o estado alvo a execu\u00e7\u00e3o termina, se n\u00e3o se escolhem aqueles que t\u00eam os melhores valores. [11] Neste algoritmo, as informa\u00e7\u00f5es s\u00e3o compartilhadas entre todos os busques que s\u00e3o executados em paralelo e se um deles tiver melhores resultados, os outros tentar\u00e3o chegar \u00e0 \u00e1rea onde ele est\u00e1. Isso pode gerar alguns problemas, pois existe a possibilidade de que os busques fiquem todos juntos em uma \u00fanica \u00e1rea o que faz com que o algoritmo perca efic\u00e1cia. Para aliviar isso uma variante conhecida como busca de feixe estoc\u00e1stico pode ser usada, onde em vez de escolher os melhores valores \u00e9 escolhido imediatamente com uma probabilidade que aumenta em rela\u00e7\u00e3o ao valor. [5]</p>"},{"location":"complex_search/#busca-local-em-espacos-continuos","title":"Busca local em espa\u00e7os cont\u00ednuos","text":"<p>Uma forma de lidar com esses ambientes \u00e9 discretiz\u00e1-los, isto \u00e9, encontrar a maneira de obter um n\u00famero limitado de pontos fixos no ambiente cont\u00ednuo, Uma maneira de fazer isso \u00e9 dividir o espa\u00e7o em uma grade retangular com espa\u00e7amento k constante e escolher os pontos na grade. Uma vez feito isso, se pode usar qualquer um dos algoritmos de busca local vistos anteriormente. [5]</p> <p>Alternativamente, poder\u00edamos fazer o fator de ramifica\u00e7\u00e3o ser finito amostrando estados sucessores aleatoriamente, movendo-nos em uma dire\u00e7\u00e3o aleat\u00f3ria em uma pequena quantidade, \u03b4. Os m\u00e9todos que medem o progresso pela mudan\u00e7a no valor da fun\u00e7\u00e3o objetivo entre dois pontos pr\u00f3ximos s\u00e3o chamados m\u00e9todos de gradiente emp\u00edrico. A busca de gradiente emp\u00edrico \u00e9 o mesmo a escalada mais \u00edngreme em uma vers\u00e3o discretizada do espa\u00e7o de estado. [5]</p>"},{"location":"complex_search/#busca-com-acoes-nao-deterministicas","title":"Busca com a\u00e7\u00f5es n\u00e3o determin\u00edsticas","text":"<p>Em ambientes parcialmente observ\u00e1veis, o agente n\u00e3o sabe em que estado se encontra e, em ambientes n\u00e3o determin\u00edsticos, o agente n\u00e3o sabe para qual estado se desloca quando uma a\u00e7\u00e3o espec\u00edfica \u00e9 executada. Por isso, nesses ambientes, \u00e9 feito uso de estados de cren\u00e7a que s\u00e3o um conjunto de estados que o agente acredita serem poss\u00edveis, tamb\u00e9m a solu\u00e7\u00e3o do problema n\u00e3o ser\u00e1 uma sequ\u00eancia de a\u00e7\u00f5es, mas um plano condicional que dir\u00e1 ao agente quais a\u00e7\u00f5es tomar dependendo do que ele receber durante a execu\u00e7\u00e3o desse plano. [5]</p> <p>Para encontrar solu\u00e7\u00f5es nesses ambientes, s\u00e3o usados arvores de busca e busca, que cont\u00eam dois tipos especiais de n\u00f3s. O primeiro tipo s\u00e3o os n\u00f3s or que representam as a\u00e7\u00f5es escolhidas pelo agente, o segundo time s\u00e3o os n\u00f3s and que representam como o ambiente reage a essas escolhas, geralmente para n\u00f3s or deve ser feita uma sele\u00e7\u00e3o de qual estado considerar enquanto que para n\u00f3s and devem ser levados em considera\u00e7\u00e3o todos os estados resultantes. Neste tipo de \u00e1rvores de busca \u00e9 muito comum que ocorram ciclos, para contrarestar estes se faz uma verifica\u00e7\u00e3o, se o estado atual for igual a um estado pertencente ao caminho desde o n\u00f3 raiz, se este for o caso, uma mensagem de falha \u00e9 retornada, o que significa que existe uma solu\u00e7\u00e3o n\u00e3o c\u00edclica que deveria ser atingida desde uma encarna\u00e7\u00e3o anterior desse estado, e ent\u00e3o a nova encarna\u00e7\u00e3o pode ser descartada. [5]</p> <p>Uma solu\u00e7\u00e3o c\u00edclica \u00e9 aquela que pode ser encontrada repetindo uma determinada a\u00e7\u00e3o at\u00e9 alcan\u00e7ar o estado desejado. Uma condi\u00e7\u00e3o m\u00ednima para que isso funcione \u00e9 que cada folha (n\u00f3 que n\u00e3o possua sucessores) seja um alvo e que pelo menos uma folha possa ser atingida a partir de qualquer ponto do plano. Outro ponto a considerar \u00e9 a causa do n\u00e3o determinismo, se este for devido a algum fato n\u00e3o observado do agente ou ambiente repetir a a\u00e7\u00e3o n\u00e3o ajudar\u00e1. [5]</p>"},{"location":"complex_search/#busca-sem-observacoes","title":"Busca sem observa\u00e7\u00f5es","text":"<p>Em tais situa\u00e7\u00f5es o agente deve procurar no espa\u00e7o de cren\u00e7a, que \u00e9 o conjunto de todos os estados poss\u00edveis, Depois disso, o agente deve realizar a\u00e7\u00f5es determin\u00edsticas que refinam esse espa\u00e7o de cren\u00e7a diminuindo o n\u00famero de estados poss\u00edveis para tentar chegar ao estado-alvo [5]. Este tipo de busca tem componentes que s\u00e3o:</p> <ul> <li>Estados: O espa\u00e7o de estado de cren\u00e7a cont\u00e9m todos os subconjuntos poss\u00edveis dos estados f\u00edsicos. Se P tiver N estados, o problema de estado de cren\u00e7a ter\u00e1 2<sup>N</sup> estados de cren\u00e7a, embora muitos deles possam ser inalcan\u00e7\u00e1veis a partir do estado inicial. [5]</li> <li>Estado inicial: Normalmente, o estado de cren\u00e7a que consiste em todos os estados em P, embora em alguns casos o agente tenha mais conhecimento do que isso. [5]</li> <li>A\u00e7\u00f5es: Se for assumido que as a\u00e7\u00f5es ilegais n\u00e3o t\u00eam efeito no ambiente, todas as a\u00e7\u00f5es poss\u00edveis podem ser realizadas para todos os estados f\u00edsicos no estado atual de cren\u00e7a; Pelo contr\u00e1rio, se as a\u00e7\u00f5es ilegais poderiam ser catastr\u00f3ficas, s\u00f3 \u00e9 seguro realizar apenas o conjunto de a\u00e7\u00f5es legais para todos os estados f\u00edsicos atuais. [5]</li> <li>Modelo de transi\u00e7\u00e3o: Para a\u00e7\u00f5es determin\u00edsticas, o novo estado de cren\u00e7a tem um estado de resultado para cada um dos estados poss\u00edveis atuais, com o n\u00e3o determinismo, o novo estado de cren\u00e7a consiste em todos os resultados poss\u00edveis da aplica\u00e7\u00e3o da a a\u00e7\u00e3o a qualquer um dos estados no estado de cren\u00e7a atual. [5]</li> <li>Teste de objetivo: O agente possivelmente encontrou o alvo se algum estado no espa\u00e7o de cren\u00e7a satisfaz a teste de objetivo; o agente definitivamente encontrou o alvo se todos os estados no espa\u00e7o de cren\u00e7a passaram no teste. [5]</li> <li>Custo de a\u00e7\u00e3o: Se a mesma a\u00e7\u00e3o pode ter custos diferentes em diferentes estados, ent\u00e3o o custo de realizar uma a\u00e7\u00e3o em um determinado estado de cren\u00e7a poderia ser um dos v\u00e1rios valores. [5]</li> </ul>"},{"location":"complex_search/#busca-online","title":"Busca online","text":"<p>Algoritmos de busca online s\u00e3o aqueles que tomam uma a\u00e7\u00e3o e esperam para ver como o ambiente reage antes de realizar a pr\u00f3xima a\u00e7\u00e3o, isso ao contr\u00e1rio dos algoritmos de busca offline em que se calcula a solu\u00e7\u00e3o completa antes de tomar o primeiro passo, a maioria dos algoritmos vistos s\u00e3o de busca offline. [5]</p> <p>As coisas que o agente sabe neste tipo de busca s\u00e3o limitadas, estas s\u00e3o:</p> <ul> <li>ACTIONS(s), as a\u00e7\u00f5es legais no estado s; [5]</li> <li>c(s,a, s\u2032), o custo de aplicar a a\u00e7\u00e3o a no estado s para chegar ao estado s\u2032. Observe que isso n\u00e3o pode ser usado at\u00e9 que o agente saiba que s\u2032 \u00e9 o resultado. [5]</li> <li>IS-GOAL(s), o teste de meta. [5]</li> </ul> <p>Uma das principais vulnerabilidades desses busques s\u00e3o os becos sem sa\u00edda, que s\u00e3o estados em que \u00e9 poss\u00edvel chegar a uma solu\u00e7\u00e3o, isto \u00e9 especialmente dif\u00edcil em explora\u00e7\u00f5es, em que certos objetos do terreno como rampas ou penhascos resultam em a\u00e7\u00f5es irrevers\u00edveis, que \u00e9 quando n\u00e3o \u00e9 poss\u00edvel voltar a um estado anterior. [5]</p> <p>Uma forma de medir a efic\u00e1cia do algoritmo de busca on-line \u00e9 atrav\u00e9s da rela\u00e7\u00e3o competitiva que \u00e9 a diferen\u00e7a entre o custo da solu\u00e7\u00e3o encontrada por meio de pesquisa on-line e o custo da solu\u00e7\u00e3o se o agente conhecesse o espa\u00e7o de busca com anteced\u00eancia, Idealmente, esse valor deve ser o menor poss\u00edvel. [5]</p> <p>Algoritmos de busca on-line funcionam muito diferente dos algoritmos de busca offline, agentes on-line recebem informa\u00e7\u00f5es ap\u00f3s cada a\u00e7\u00e3o que lhes diz em qual estado ele chegou, esta informa\u00e7\u00e3o \u00e9 usada para atualizar seu mapa do ambiente e planejar sua pr\u00f3xima a\u00e7\u00e3o. Isso significa que em algoritmos on-line voc\u00ea s\u00f3 pode explorar o espa\u00e7o de busca tomando a\u00e7\u00f5es reais, enquanto em algoritmos off-line o espa\u00e7o de busca pode ser explorado por simula\u00e7\u00f5es. [5]</p> <p>Para fazer buscas em espa\u00e7os online busca de escalada n\u00e3o \u00e9 suficiente pois pode deixar o agente preso em um local m\u00e1ximo. Para usar esse algoritmo, aumentar a escalada com mem\u00f3ria em vez de aleatoriedade \u00e9 uma abordagem mais eficaz. A ideia b\u00e1sica \u00e9 armazenar uma \u00abmelhor estimativa atual\u00bb H(s) do custo de atingir o objetivo de cada estado visitado. H(s) come\u00e7a sendo apenas a estimativa heur\u00edstica h(s) e \u00e9 atualizado \u00e0 medida que o agente ganha experi\u00eancia no espa\u00e7o de estados. [5]</p> <p>Um agente que implemente esse esquema, chamado de aprendizado em tempo real A (LRTA) constr\u00f3i um mapa do ambiente na tabela de resultados. Atualiza a estimativa de custo para o estado que se acabou de abandonar e, em seguida, escolhe o movimento \u00abaparentemente melhor\u00bb com base nas estimativas de custos atuais. Um detalhe importante \u00e9 que sempre se sup\u00f5e que as a\u00e7\u00f5es que ainda n\u00e3o foram tentadas em um estado s conduzem imediatamente ao objetivo com o menor custo poss\u00edvel, isto \u00e9, h(s). No pior dos casos, esse agente \u00e9 capaz de explorar um ambiente com n estados em O(n<sup>2</sup>) passos, embora na maioria dos casos ele costuma ter melhor desempenho. [5]</p> <p>Para aprender os agentes de busca online realizam duas etapas, primeiro voc\u00ea deve criar um mapa do ambiente, que ser\u00e1 formado por todos os resultados de todas as a\u00e7\u00f5es em cada estado, o segundo passo \u00e9 obter estimativas mais precisas do custo de cada estado usando normas locais de atualiza\u00e7\u00e3o. [5]</p>"},{"location":"complex_search/#exemplo-de-implementacao-de-busca-em-ambientes-complexos","title":"Exemplo de implementa\u00e7\u00e3o de busca em ambientes complexos","text":"<p>Algoritmo que usa escalada para resolver o problema do vendedor viajante em que se tenta encontrar a rota mais curta poss\u00edvel que visita cada cidade e, posteriormente, retorna ao ponto de origem.</p> <pre><code>\nimport numpy as np\nimport random\n\nnp.random.seed(42)\nrandom.seed(42)\n\nnum_cities = 10\ncities = np.random.rand(num_cities, 2)\n\ndef calculate_distance(route):\n    route_extended = np.append(route, [route[0]], axis=0)\n    return np.sum(np.sqrt(np.sum(np.diff(route_extended, axis=0)**2, axis=1)))\n\ndef create_initial_route(cities):\n    return np.array(random.sample(list(cities), len(cities)))\n\ndef get_neighbors(route):\n    neighbors = []\n    for i in range(len(route)):\n        for j in range(i + 1, len(route)):\n            neighbor = route.copy()\n            neighbor[i], neighbor[j] = neighbor[j], neighbor[i]\n            neighbors.append(neighbor)\n    return neighbors\n\ndef hill_climbing(cities):\n    current_route = create_initial_route(cities)\n    current_distance = calculate_distance(current_route)\n\n    while True:\n        neighbors = get_neighbors(current_route)\n        next_route = min(neighbors, key=calculate_distance)\n        next_distance = calculate_distance(next_route)\n\n        if next_distance &gt;= current_distance:\n            break\n\n        current_route, current_distance = next_route, next_distance\n\n    return current_route, current_distance\n\nhc_route, hc_distance = hill_climbing(cities)\n\nprint(\"Hill Climbing:\")\nprint(\"Route:\", hc_route)\nprint(\"Distance:\", hc_distance)\n\n</code></pre>"},{"location":"conclusion_first/","title":"Conclus\u00e3o","text":"<p>Existe uma grande quantidade de algoritmos de busca que se adaptam a uma grande quantidade de situa\u00e7\u00f5es, a escolha destes depender\u00e1 de certas caracter\u00edsticas do ambiente assim como uma decis\u00e3o entre velocidade de execu\u00e7\u00e3o e precis\u00e3o da solu\u00e7\u00e3o encontrada. Outra parte muito importante \u00e9 a escolha da heur\u00edstica, pois em muitos algoritmos a qualidade das respostas encontradas depende em grande parte da qualidade da heur\u00edstica encontrada e, portanto, uma quantidade consider\u00e1vel de tempo deve ser tomada apenas para analisar e escolher uma heur\u00edstica que se adapte ao problema enfrentado. Se levar em conta esses pontos, se pode encontrar uma solu\u00e7\u00e3o para qualquer problema de busca que voc\u00ea est\u00e1 enfrentando.</p>"},{"location":"conclusion_second/","title":"Conclus\u00e3o","text":"<p>A introdu\u00e7\u00e3o de condi\u00e7\u00f5es para os problemas adiciona outra camada de complexidade \u00e0 sua resolu\u00e7\u00e3o bastante significativa. Que tanto influenciar\u00e1 a condi\u00e7\u00e3o no processo de resolu\u00e7\u00e3o depende do seu tipo, pois existem condi\u00e7\u00f5es que devem ser cumpridas obrigatoriamente e existem condi\u00e7\u00f5es que podem ser ignoradas mesmo que isso seja por um custo. Definir e cumprir condi\u00e7\u00f5es nos d\u00e1 a capacidade de obter solu\u00e7\u00f5es mais precisas e que se ajustam melhor \u00e0s exig\u00eancias dos problemas, no entanto deve-se ter em conta que o processo para obter tais solu\u00e7\u00f5es \u00e9 mais complexo.</p>"},{"location":"consistency/","title":"Consist\u00eancia","text":"<p>Os valores dados \u00e0s vari\u00e1veis s\u00e3o conhecidos como atribui\u00e7\u00f5es, uma atribui\u00e7\u00e3o que n\u00e3o viola nenhuma condi\u00e7\u00e3o \u00e9 conhecida como consistente, uma atribui\u00e7\u00e3o completa \u00e9 quando todas as vari\u00e1veis t\u00eam um valor e, finalmente, uma solu\u00e7\u00e3o \u00e9 uma atribui\u00e7\u00e3o consistente e completa. Por outro lado, quando h\u00e1 vari\u00e1veis que n\u00e3o t\u00eam nenhum valor, isso \u00e9 conhecido como atribui\u00e7\u00e3o parcial e uma solu\u00e7\u00e3o parcial \u00e9 uma atribui\u00e7\u00e3o parcial consistente. [1]</p>"},{"location":"consistency/#consistencia-de-nos","title":"Consist\u00eancia de n\u00f3s","text":"<p>Consist\u00eancia de n\u00f3 refere-se a quando o dom\u00ednio de uma \u00fanica vari\u00e1vel cumpre todas as condi\u00e7\u00f5es impostas a ela. Ex: A vari\u00e1vel A tem um dom\u00ednio de {2, 4, 6, 8} e tem uma condi\u00e7\u00e3o que estipula que A n\u00e3o pode ser divis\u00edvel por 3, para que A possa ter consist\u00eancia de n\u00f3 6 deve ser removido do dom\u00ednio. Um grafo \u00e9 dito ter consist\u00eancia de n\u00f3 quando todas as vari\u00e1veis do grafo s\u00e3o consistentes de n\u00f3. [1]</p>"},{"location":"consistency/#consistencia-do-arco","title":"Consist\u00eancia do arco","text":"<p>Uma vari\u00e1vel \u00e9 arco consistente se todos os valores do seu dom\u00ednio satisfazem suas condi\u00e7\u00f5es bin\u00e1rias. Ex: A e B possuem um dom\u00ednio tal que {(1,2),(2,3),(3,4),(6,5)} respetivamente, mas possuem uma condi\u00e7\u00e3o que estipula que A &lt; B, para que se possa considerar arco consistente a A em rela\u00e7\u00e3o a B deve-se restringir seu dom\u00ednio a {1, 2, 3} e para que B possa ser considerado um arco consistente em rela\u00e7\u00e3o a A, seu dom\u00ednio deve ser restrito a {2, 3, 4}. Um grafo \u00e9 considerado consistente se todas as suas vari\u00e1veis s\u00e3o consistentes entre si. [1]</p>"},{"location":"consistency/#consistencia-do-caminho","title":"Consist\u00eancia do caminho","text":"<p>Vari\u00e1veis s\u00e3o consideradas consist\u00eancia de caminho quando n\u00e3o t\u00eam consist\u00eancia bin\u00e1ria entre si, mas tamb\u00e9m s\u00e3o consistentes com uma terceira vari\u00e1vel, por uma condi\u00e7\u00e3o impl\u00edcita. Ex: Voc\u00ea tem as vari\u00e1veis A, B e C com dom\u00ednios {1, 2, 3}; {2, 3} e {3, 4} respectivamente e t\u00eam as condi\u00e7\u00f5es A &lt; B, A /= C e B /= C para que A e B tenham consist\u00eancia de caminho em rela\u00e7\u00e3o a C deve-se reduzir o dom\u00ednio de A para {1, 2} e o de B para {2}. [1]</p>"},{"location":"consistency/#consistencia-k","title":"Consist\u00eancia K","text":"<p>A k-Consist\u00eancia generaliza o conceito de consist\u00eancia de arco e caminho para k vari\u00e1veis. Ela garante que, para cada subconjunto de k-1 vari\u00e1veis, haja um valor consistente na k-\u00e9sima vari\u00e1vel. N\u00edveis mais altos de consist\u00eancia proporcionam mais poda, mas s\u00e3o computacionalmente mais caros. [8]</p>"},{"location":"consistency/#consistencia-global","title":"Consist\u00eancia global","text":"<p>As restri\u00e7\u00f5es globais ocorrem com frequ\u00eancia em problemas reais e podem ser tratadas por algoritmos para fins especiais que s\u00e3o mais eficientes do que os m\u00e9todos para fins gerais descritos at\u00e9 agora. O algoritmo \u00e9 o seguinte: Primeiro, remova qualquer vari\u00e1vel da restri\u00e7\u00e3o que tenha um dom\u00ednio \u00fanico e exclua o valor dessa vari\u00e1vel dos dom\u00ednios das vari\u00e1veis restantes. Repita o procedimento enquanto houver vari\u00e1veis singleton. Se em algum momento for produzido um dom\u00ednio vazio ou se houver mais vari\u00e1veis do que valores de dom\u00ednio restantes, ent\u00e3o foi detectada uma inconsist\u00eancia. [1]</p> <p>Para grandes problemas de recursos limitados com valores inteiros, geralmente n\u00e3o \u00e9 poss\u00edvel representar o dom\u00ednio de cada vari\u00e1vel como um grande conjunto de n\u00fameros inteiros e reduzir gradualmente esse conjunto por meio de m\u00e9todos de verifica\u00e7\u00e3o de consist\u00eancia. Em vez disso, os dom\u00ednios s\u00e3o representados por limites superiores e inferiores e s\u00e3o gerenciados pela propaga\u00e7\u00e3o de limites. Neste caso, o processo altera os limites superiores e inferiores dos intervalos para que estes cumpram as condi\u00e7\u00f5es. [1]</p>"},{"location":"genetic_algoritms/","title":"Algoritmos gen\u00e9ticos","text":"<p>Algoritmos gen\u00e9ticos usam processos que imitam os comportamentos dos seres vivos, especificamente aqueles comportamentos relacionados com a evolu\u00e7\u00e3o biol\u00f3gica como reprodu\u00e7\u00e3o, muta\u00e7\u00e3o e recombina\u00e7\u00e3o. [13] Para tais algoritmos as solu\u00e7\u00f5es mais fracas s\u00e3o eliminadas, enquanto as op\u00e7\u00f5es mais fortes e vi\u00e1veis s\u00e3o mantidas e reavaliadas na evolu\u00e7\u00e3o seguinte, isto a fim de chegar \u00e0s a\u00e7\u00f5es mais \u00f3timas para alcan\u00e7ar o estado desejado. [13] A forma como isso \u00e9 feito \u00e9 de uma lista de indiv\u00edduos (estados) escolhe-se aqueles que t\u00eam o melhor valor e desses estados selecionados produz-se estados sucessores que ser\u00e3o a lista de indiv\u00edduos para a pr\u00f3xima gera\u00e7\u00e3o, este \u00faltimo processo \u00e9 conhecido como recombina\u00e7\u00e3o. [5]</p> <p>Elementos importantes de estos algorimos son:</p> <ul> <li>O tamanho da popula\u00e7\u00e3o (O n\u00famero de estados iniciais). [5]</li> <li>A representa\u00e7\u00e3o de cada indiv\u00edduo. Nos algoritmos gen\u00e9ticos, cada indiv\u00edduo \u00e9 uma cadeia sobre um alfabeto finito (muitas vezes uma cadeia booleana). [5]</li> <li>O n\u00famero de combina\u00e7\u00e3o p, que \u00e9 o n\u00famero de estados que se combinam para criar um sucessor, o n\u00famero mais comum \u00e9 dois, embora existam situa\u00e7\u00f5es em que este \u00e9 maior. [5]</li> <li>O processo de sele\u00e7\u00e3o que ir\u00e1 selecionar quais estados se tornar\u00e3o pais na pr\u00f3xima gera\u00e7\u00e3o, um exemplo deste processo \u00e9 uma sele\u00e7\u00e3o aleat\u00f3ria, outra forma \u00e9 probabilidades que sejam proporcionais ao qu\u00e3o adequado seu valor seja. [5]</li> <li>O processo de recombina\u00e7\u00e3o, que \u00e9 a forma como os estados pai se combinam para criar sucessores, uma abordagem comum \u00e9 escolher aleatoriamente um ponto onde os estados pai s\u00e3o cortados e as duas partes resultantes s\u00e3o combinadas. [5]</li> <li>A taxa de muta\u00e7\u00e3o, uma vez que um sucessor \u00e9 gerado todos os seus bits t\u00eam uma probabilidade igual \u00e0 taxa de muta\u00e7\u00e3o de ser virada (1 para 0/0 para 1). [5]</li> <li>A composi\u00e7\u00e3o da pr\u00f3xima gera\u00e7\u00e3o. Duas pr\u00e1ticas comuns s\u00e3o elitismo, em que n\u00e3o apenas sucessores, mas tamb\u00e9m pais de alto valor comp\u00f5em a pr\u00f3xima gera\u00e7\u00e3o; o outro \u00e9 conhecido como sacrif\u00edcio no qual estados com valor abaixo de um limite s\u00e3o eliminados. [5]</li> </ul> <p>Um esquema s\u00e3o estados que cont\u00eam em que algumas das posi\u00e7\u00f5es s\u00e3o deixadas sem especificar, a partir destes s\u00e3o criadas inst\u00e2ncias que s\u00e3o estados que compartilham as posi\u00e7\u00f5es especificadas enquanto as posi\u00e7\u00f5es n\u00e3o especificadas podem variar, se o valor m\u00e9dio das inst\u00e2ncias for maior que o valor m\u00e9dio total, o n\u00famero de inst\u00e2ncias do esquema aumentar\u00e1. Esses esquemas s\u00e3o usados para que blocos \u00fateis sejam combinados com outros blocos para chegar a uma solu\u00e7\u00e3o. [5]</p>"},{"location":"genetic_algoritms/#exemplo-de-implementacao-de-algoritmos-geneticos","title":"Exemplo de implementa\u00e7\u00e3o de algoritmos gen\u00e9ticos","text":"<p>Exemplo b\u00e1sico de algoritmos gen\u00e9ticos em que se tenta encontrar os valores de x, y e z que far\u00e3o com que o resultado de uma fun\u00e7\u00e3o espec\u00edfica seja o mais pr\u00f3ximo poss\u00edvel de zero. Neste algoritmo, a combina\u00e7\u00e3o e muta\u00e7\u00e3o s\u00e3o implementadas.</p> <pre><code>\nimport random\n\ndef foo(x, y, z):\n    return 6*x**3 + 9*y**2 + 90*z - 25\n\ndef fitness(x, y, z):\n    ans = foo(x, y, z)\n\n    if ans == 0:\n        return 99999\n    else:\n        return abs(1/ans)\n\nsolutions = []\nfor s in range(1000):\n    solutions.append((random.uniform(0,10000),\n                      random.uniform(0,10000),\n                      random.uniform(0,10000)))\n\nfor i in range(10000):\n    rankedsolutions = []\n    for s in solutions:\n        rankedsolutions.append((fitness(s[0],s[0],s[0]),s))\n    rankedsolutions.sort\n    rankedsolutions.reverse\n\n    print(f\"=== Gen {i} best solutions ===\")\n    print(rankedsolutions[0])\n\n    if rankedsolutions[0][0] &gt; 999:\n        break\n\n    bestsolutions = rankedsolutions[:100]\n\n    elements = []\n    for s in bestsolutions:\n        elements.append(s[1][0])\n        elements.append(s[1][1])\n        elements.append(s[1][2])\n\n    newGen = []\n    for _ in range(1000):\n        e1 = random.choice(elements) * random.uniform(0.99, 1.01)\n        e2 = random.choice(elements) * random.uniform(0.99, 1.01)\n        e3 = random.choice(elements) * random.uniform(0.99, 1.01)\n\n        newGen.append((e1, e2, e3))\n\n    solutions = newGen\n\n</code></pre>"},{"location":"heuristic_functions/","title":"Fun\u00e7\u00f5es Heur\u00edsticas","text":"<p>Fun\u00e7\u00f5es heur\u00edsticas s\u00e3o aquelas fun\u00e7\u00f5es usadas para determinar qu\u00e3o pr\u00f3ximo um determinado estado est\u00e1 do estado desejado, elas variam e devem ser modificadas para satisfazer problemas espec\u00edficos. S\u00e3o usadas quando n\u00e3o se tem uma solu\u00e7\u00e3o fixa ou quando demora muito tempo encontrar uma solu\u00e7\u00e3o para o problema, seu prop\u00f3sito \u00e9 encontrar uma solu\u00e7\u00e3o mais aproximada ou de forma mais r\u00e1pida. [11]</p>"},{"location":"heuristic_functions/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Admiss\u00edvel: Uma heur\u00edstica \u00e9 admiss\u00edvel quando produz uma solu\u00e7\u00e3o \u00f3tima, ou seja, n\u00e3o superestima o custo de chegar ao estado-objetivo. [11]</li> <li>Completa: Uma heur\u00edstica \u00e9 completa se o algoritmo que a usa acaba em uma solu\u00e7\u00e3o. [11]</li> <li>Propriedade de domina\u00e7\u00e3o: Se houver dois algoritmos heur\u00edsticos que usam duas fun\u00e7\u00f5es heur\u00edsticas diferentes, o algoritmo que domina o outro ser\u00e1 aquele que usa a melhor heur\u00edstica para todos os n\u00f3s. [11]</li> <li>Propriedade de optimalidade: O algoritmo que produz o melhor resultado ser\u00e1 aquele que \u00e9 minucioso, permiss\u00edvel e domina os outros algoritmos. [11]</li> </ul>"},{"location":"heuristic_functions/#qualidade","title":"Qualidade","text":"<p>Existem duas propostas para medir a qualidade de uma heur\u00edstica a primeira \u00e9 o fator de ramifica\u00e7\u00e3o efetiva (b) que \u00e9 calculado pela seguinte f\u00f3rmula N + 1 = 1 + b + (b)<sup>2</sup> + ... + (b)<sup>d</sup> em que N \u00e9 o n\u00famero de n\u00f3s gerados pelo algoritmo e d \u00e9 a profundidade onde a solu\u00e7\u00e3o est\u00e1. Quanto melhor a heur\u00edstica, mais pr\u00f3ximo de um estar\u00e1 o valor do fator de ramifica\u00e7\u00e3o efetivo. [5]</p> <p>Outra forma de medir a qualidade \u00e9 a redu\u00e7\u00e3o da profundidade efetiva comparado com a profundidade real d, que resulta em uma redu\u00e7\u00e3o do custo de busca O(b<sup>d</sup>) para O(b<sup>d - kh</sup>), quanto maior for a redu\u00e7\u00e3o melhor ser\u00e1 a heur\u00edstica. [5]</p>"},{"location":"heuristic_functions/#geracao-de-heuristicas","title":"Gera\u00e7\u00e3o de heur\u00edsticas","text":""},{"location":"heuristic_functions/#problemas-relaxados","title":"Problemas relaxados","text":"<p>Um problema relaxado \u00e9 uma vers\u00e3o de um problema j\u00e1 existente com menos restri\u00e7\u00f5es nas a\u00e7\u00f5es que podem ser realizadas, vendo-o a partir da abordagem de um grafo de estados o problema relaxado \u00e9 um supergrafo comparado ao problema normal, pois o menor n\u00famero de restri\u00e7\u00f5es resulta em um maior n\u00famero de bordas. Porque o grafo de estado do problema original est\u00e1 dentro do grafo de estado do problema relaxado qualquer solu\u00e7\u00e3o do problema original tamb\u00e9m se aplica ao problema relaxado, mas devido \u00e0s bordas extras \u00e9 poss\u00edvel encontrar atalhos que podem resultar em uma melhor solu\u00e7\u00e3o para o problema original. [5]</p>"},{"location":"heuristic_functions/#sub-problemas","title":"Sub-problemas","text":"<p>Heur\u00edsticas tamb\u00e9m podem ser geradas pelo custo de resolver um subproblema, ou seja, alguns elementos do problema s\u00e3o levados em conta e outros s\u00e3o ignorados. A forma como isso \u00e9 feito \u00e9 atrav\u00e9s de bancos de dados padr\u00e3o em que todos os custos de solu\u00e7\u00e3o de todos os poss\u00edveis subproblemas s\u00e3o armazenados, depois calcula-se a heur\u00edstica de um estado simplesmente procurando o subproblema que cont\u00e9m no banco de dados. Se um estado tiver v\u00e1rios subproblemas poss\u00edveis que possam ser aplicados para decidir qual heur\u00edstica usar, todas as heur\u00edsticas poss\u00edveis ser\u00e3o combinadas e a que tiver o melhor valor ser\u00e1 escolhida. Nesses subproblemas os elementos que n\u00e3o fazem parte do subproblema s\u00e3o abstra\u00eddos, ou seja, n\u00e3o se levam em conta para a solu\u00e7\u00e3o mas sim devem ser levados em considera\u00e7\u00e3o nos movimentos que se realizam para chegar a esse resultado. [5]</p> <p>Si es que se quiere aplicar multiples subproblemas a un estado pues estos no se sobreponen se deber\u00e1 aplicar bases de datos de patrones disjuntos las cuales son similares a las bases de datos de patrones regulares excepto que en lugar de registrar el costo total de resolver el subproblema apenas o custo dos movimentos que envolvem os elementos membros do subproblema \u00e9 calculado, ou seja, em vez de abstrair elementos que n\u00e3o fazem parte do subproblema estes j\u00e1 n\u00e3o s\u00e3o levados em conta. Isso funciona porque os elementos que n\u00e3o s\u00e3o considerados em um subproblema aplicado ser\u00e3o considerados para outro subproblema que \u00e9 aplicado ao mesmo estado. No final somam-se os custos de resolu\u00e7\u00e3o de todos os subproblemas aplicados e isto resulta em um custo menor do que seria necess\u00e1rio resolver todo o problema. [5]</p>"},{"location":"heuristic_functions/#pontos-de-referencia","title":"Pontos de refer\u00eancia","text":"<p>Consiste em criar alguns (10 a 20) pontos de refer\u00eancia dentro do gr\u00e1fico e calcular o custo da trajet\u00f3ria \u00f3tima de cada n\u00f3 ao ponto de refer\u00eancia e vice-versa C (n, L) e C (L, n); num gr\u00e1fico n\u00e3o direcionado o c\u00e1lculo dos dois \u00e9 igual, em um gr\u00e1fico n\u00e3o direcionado devem ser calculados separadamente. Depois de calcular a heur\u00edstica somar o custo de chegar ao ponto de refer\u00eancia e o custo do ponto de refer\u00eancia para o objetivo, finalmente se escolhe o custo m\u00ednimo de todos os pontos de refer\u00eancia, isto pode ser visualizado assim hL(n) = min(L\u2208Landmarks) (C(n, L) + C(L, objetivo)). Essa heur\u00edstica s\u00f3 funciona se o caminho \u00f3timo passa por um ponto de refer\u00eancia, caso contr\u00e1rio \u00e9 inadmiss\u00edvel. [5]</p> <p>Uma forma de tornar essa heur\u00edstica admiss\u00edvel \u00e9 usando hDH(n) = max(L Landmarks)(|C (n,L) C (goal,L)|) em que se escoge um ponto de refer\u00eancia que este mais longe do que o objetivo para depois tra\u00e7ar o caminho mais ideal ao ponto de refer\u00eanica, Finalmente, o tra\u00e7o final do alvo ao ponto de refer\u00eancia \u00e9 removido para obter o custo do caminho de n ao objetivo. Esta heur\u00edstica \u00e9 admiss\u00edvel, pois n\u00e3o superestima o custo para o objetivo, no entanto se o objetivo n\u00e3o est\u00e1 no caminho \u00f3timo para o ponto de refer\u00eancia essa heur\u00edstica ser\u00e1 imprecisa. Isso \u00e9 conhecido como uma heur\u00edstica diferencial devido \u00e0 subtrac\u00e7\u00e3o. [5]</p> <p>Para escolher pontos de refer\u00eancia \u00e9 recomendado que estes sejam o mais longe um do outro como poss\u00edvel, uma maneira gananciosa de fazer isso \u00e9 escolher um ponto de refer\u00eancia aleat\u00f3rio e encontrar o n\u00f3 que est\u00e1 mais longe desse ponto para depois adicion\u00e1-lo \u00e0 lista de pontos de refer\u00eancia, este processo \u00e9 repetido at\u00e9 que a quantidade desejada de pontos tenha sido adicionada. Para heur\u00edstica diferencial \u00e9 recomendado que os pontos de refer\u00eancia est\u00e3o distribu\u00eddos em torno do per\u00edmetro do grafo, para garantir isso \u00e9 o centro do grafo realizar k \"cortes\" em forma de peda\u00e7o de torta ao redor do centro, e em cada corte selecionar o v\u00e9rtice que est\u00e1 mais longe do centro. [5]</p>"},{"location":"heuristic_functions/#experiencia","title":"Experi\u00eancia","text":"<p>Usar a experi\u00eancia para obter heur\u00edsticas usando exemplos de caminho/objetivo feitos com base em resolu\u00e7\u00f5es anteriores de problemas do mesmo tipo. Usando esses exemplos, construa-se uma fun\u00e7\u00e3o h que aproximar\u00e1 o verdadeiro custo de caminho de algum estado/n\u00f3 que aparecer durante a busca. A aproxima\u00e7\u00e3o \u00e0 fun\u00e7\u00e3o heur\u00edstica desta abordagem \u00e9 imperfeita, pelo que sempre se faz um compromisso entre o tempo de aprendizagem, o tempo de execu\u00e7\u00e3o da busca e o custo da solu\u00e7\u00e3o. [5]</p> <p>Outra maneira de fazer isso \u00e9 usando caracter\u00edsticas do problema que s\u00e3o relevantes para prever o valor heur\u00edstico do estado. Dependendo do valor dessas caracter\u00edsticas, pode-se encontrar um certo valor m\u00e9dio de resolu\u00e7\u00e3o do problema. Para melhores resultados, m\u00faltiplas caracter\u00edsticas podem ser combinadas usando a f\u00f3rmula h(n) = c1x1(n) + c2x2(n) onde x1 e x2 s\u00e3o as caracter\u00edsticas e c1 e c2 s\u00e3o constantes que devem ser ajustadas para obter os melhores resultados. [5]</p>"},{"location":"open-closed-problems/","title":"Problemas de malha aberta e de malha fechada","text":"<p>Os problemas que um agente IA enfrenta s\u00e3o influenciados por m\u00faltiplas circunst\u00e2ncias do ambiente, estes podem ser classificados em dois tipos de problemas de malha aberta e problemas de malha fechada.</p>"},{"location":"open-closed-problems/#problemas-de-malha-aberta","title":"Problemas de malha aberta","text":"<p>Ocorrem em ambientes totalmente observ\u00e1veis e determin\u00edsticos [5], o agente realiza a\u00e7\u00f5es predefinidas sem nenhum tipo de feedback cont\u00ednuo, comandos fixos s\u00e3o executados sem ajustes durante a execu\u00e7\u00e3o.[3] Neste tipo de ambientes a resolu\u00e7\u00e3o do problema ser\u00e1 sempre uma sequ\u00eancia de a\u00e7\u00f5es fixas.</p> <p></p> <p>Exemplo de problema de malha aberta.</p>"},{"location":"open-closed-problems/#vantagens","title":"Vantagens","text":"<ul> <li>Desenho e implementa\u00e7\u00e3o simples. [4]</li> <li>Baixo custo de manuten\u00e7\u00e3o. [4]</li> <li>Alta velocidade de opera\u00e7\u00e3o. [4]</li> </ul>"},{"location":"open-closed-problems/#desvantagens","title":"Desvantagens","text":"<ul> <li>Baixa precis\u00e3o e exatid\u00e3o. [4]</li> <li>Vulner\u00e1vel a varia\u00e7\u00f5es externas. [4]</li> </ul>"},{"location":"open-closed-problems/#problemas-de-malha-fechada","title":"Problemas de malha fechada","text":"<p>Ocorrem em ambientes n\u00e3o-determin\u00edsticos ou que possam possuir informa\u00e7\u00f5es que s\u00f3 s\u00e3o reveladas durante a execu\u00e7\u00e3o [5], o agente basear\u00e1 suas a\u00e7\u00f5es no feedback constante obtido atrav\u00e9s de sensores e atuadores, as a\u00e7\u00f5es ser\u00e3o monitoradas constantemente e ajustes em tempo real ser\u00e3o feitos para garantir que o objetivo seja alcan\u00e7ado. [3]</p> <p></p> <p>Exemplo de problema de malha fechada.</p>"},{"location":"open-closed-problems/#vantagens_1","title":"Vantagens","text":"<ul> <li>Alta precis\u00e3o e exatid\u00e3o. [4]</li> <li>Resistente a varia\u00e7\u00f5es externas. [4]</li> </ul>"},{"location":"open-closed-problems/#desvantagens_1","title":"Desvantagens","text":"<ul> <li>Desenho e implementa\u00e7\u00e3o complexa. [4]</li> <li>Alto custo de manuten\u00e7\u00e3o [4]</li> <li>Menor velocidade de opera\u00e7\u00e3o em compara\u00e7\u00e3o com agentes projetados para problemas de malha aberta. [4]</li> </ul>"},{"location":"problem_solution_agent/","title":"Agente de solu\u00e7\u00f5es de problemas","text":"<p>(geeksforgeeks e skillvertex - Hridhya Manoj) S\u00e3o um tipo de agente projetado para perceber seu ambiente e agir para atingir um objetivo, ao contr\u00e1rio de um agente reflexo que s\u00f3 reage a est\u00edmulos, um agente de solu\u00e7\u00e3o de problemas \u00e9 especializado em identificar e resolver situa\u00e7\u00f5es sistematicamente.[1] Alguns usos para esses agentes s\u00e3o encontrados em algoritmos de jogo, rob\u00f3tica e sistemas de tomada de decis\u00e3o.[2]</p>"},{"location":"problem_solution_agent/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Percep\u00e7\u00e3o: T\u00eam a capacidade de obter informa\u00e7\u00e3o do seu ambiente. [2]</li> <li>Racioc\u00ednio: Capacidade de processar informa\u00e7\u00f5es, fazer infer\u00eancias e decidir quais s\u00e3o as a\u00e7\u00f5es mais adequadas baseadas na percep\u00e7\u00e3o e no conhecimento pr\u00e9vio. [2]</li> <li>Planejamento: Considera\u00e7\u00e3o de m\u00faltiplas sequ\u00eancias de a\u00e7\u00f5es para atingir objetivos, geralmente usado para problemas complexos. [2]</li> <li>Feedback: Capacidade de receber feedback do ambiente que eles usam para ajustar suas a\u00e7\u00f5es e estrat\u00e9gias. [2]</li> <li>Aprendizagem: Incorporam estrat\u00e9gias de aprendizado de m\u00e1quina para melhorar seu desempenho ao longo do tempo. [2]</li> </ul>"},{"location":"problem_solution_agent/#passos-para-resolucao-de-problemas","title":"Passos para resolu\u00e7\u00e3o de problemas","text":"<ol> <li>Defini\u00e7\u00e3o do problema: Nesta primeira fase, deve-se especificar claramente quais s\u00e3o as poss\u00edveis situa\u00e7\u00f5es e solu\u00e7\u00f5es aceit\u00e1veis para o sistema. [1]</li> <li>An\u00e1lise de problema: Nesta fase, os componentes e restri\u00e7\u00f5es do problema s\u00e3o cuidadosamente analisados, verificando quais solu\u00e7\u00f5es s\u00e3o vi\u00e1veis. [1]</li> <li>Representa\u00e7\u00e3o do conhecimento: Nesta fase, todas as informa\u00e7\u00f5es obtidas sobre o problema s\u00e3o coletadas para definir quais t\u00e9cnicas podem ser usadas. [1]</li> <li>Resolu\u00e7\u00e3o do problema: As melhores t\u00e9cnicas para a solu\u00e7\u00e3o do problema s\u00e3o coletadas e comparadas para determinar qual \u00e9 o melhor m\u00e9todo. [1]</li> </ol>"},{"location":"problem_solution_agent/#componentes","title":"Componentes","text":"<ul> <li>Estado inicial: Estado inicial para o agente, estabelecendo o contexto do problema, aqui tamb\u00e9m inicializam-se os m\u00e9todos para a resolu\u00e7\u00e3o de problemas. [1]</li> <li>A\u00e7\u00e3o: Aqui \u00e9 onde todas as a\u00e7\u00f5es poss\u00edveis s\u00e3o identificadas com base no estado inicial. [1]</li> <li>Transi\u00e7\u00e3o: Verifica como as a\u00e7\u00f5es afetam o estado do problema e leva-o para a pr\u00f3xima fase do processo de solu\u00e7\u00e3o. [1]</li> <li>Teste de objetivo: Verifica se o estado alvo foi alcan\u00e7ado usando o m\u00f3dulo de transi\u00e7\u00e3o, se este \u00e9 o caso, interrompe as a\u00e7\u00f5es e se concentra em calcular o custo para atingir esse objetivo. [1]</li> <li>Custo de trajeto: Este componente atribui um valor num\u00e9rico \u00e0 solu\u00e7\u00e3o alcan\u00e7ada, leva em conta o uso de hardware, software e recursos humanos. [1]</li> </ul>"},{"location":"problem_solution_agent/#dificuldades","title":"Dificuldades","text":"<ul> <li>Complexidade: Problemas complexos exigem uma grande quantidade de tempo e recursos computacionais. [1]</li> <li>Qualidade de dados: A qualidade das solu\u00e7\u00f5es \u00e9 muito dependente da qualidade dos dados que s\u00e3o fornecidos ao sistema. [1]</li> <li>Interpretabilidade: V\u00e1rios modelos de IA atuam como \"caixas pretas\" o que impede a compreens\u00e3o do seu processo de tomada de decis\u00e3o. [1]</li> <li>\u00c9tica e preconceito: Preconceitos encontrados na data podem ser refletidos no agente o que pode alterar a qualidade das solu\u00e7\u00f5es. [1]</li> </ul>"},{"location":"problem_structure/","title":"Estrutura de problemas","text":"<p>Quando se trata de resolver problemas de satisfa\u00e7\u00e3o de condi\u00e7\u00f5es, a situa\u00e7\u00e3o ideal \u00e9 que este seja em forma de arvore, pois s\u00e3o mais f\u00e1ceis de resolver porque evitam os ciclos, duas vari\u00e1veis quaisquer est\u00e3o conectadas por um \u00fanico caminho e estes podem ser resolvidos em tempo linear O(nd<sup>2</sup>) se a consist\u00eancia do arco dirigido \u00e9 assegurada. Um CSP \u00e9 definido como consistente em arco direcional consistente em arco direcional sob uma ordena\u00e7\u00e3o de vari\u00e1veis X1, X2, . . . ,Xn se e somente se cada Xi for arco-consistente com cada Xj para j &gt; i. Al\u00e9m disso, j\u00e1 temos um algoritmo bastante confi\u00e1vel para resolver esses tipos de problemas. [1]</p> <ul> <li>Etapa 1: Selecione uma vari\u00e1vel raiz e fa\u00e7a uma classifica\u00e7\u00e3o topol\u00f3gica das vari\u00e1veis com base na estrutura da \u00e1rvore. [1]</li> <li>Etapa 2: tornar o gr\u00e1fico consistente com o arco direcionado em O(nd<sup>2</sup>). [1]</li> <li>Etapa 3: Atribua valores \u00e0s vari\u00e1veis linearmente na lista ordenada sem retrocesso, pois a consist\u00eancia do arco garante atribui\u00e7\u00f5es v\u00e1lidas para os filhos, dadas as atribui\u00e7\u00f5es dos pais. [1]</li> </ul> <p>Agora que temos um algoritmo eficiente para \u00e1rvores, podemos considerar se os gr\u00e1ficos de restri\u00e7\u00f5es mais gerais podem ser reduzidos a \u00e1rvores de alguma forma. H\u00e1 duas maneiras de fazer isso: removendo os n\u00f3s ou colapsando os n\u00f3s. [1]</p>"},{"location":"problem_structure/#condicionamento-de-corte","title":"Condicionamento de corte","text":"<p>O condicionamento de conjunto de cortes \u00e9 uma t\u00e9cnica para resolver CSPs quase estruturados em \u00e1rvore em que algumas vari\u00e1veis s\u00e3o atribu\u00eddas separadamente do restante, removidas do gr\u00e1fico de restri\u00e7\u00f5es e deixando um CSP estruturado em \u00e1rvore para as vari\u00e1veis restantes. [9]</p> <p>Os conjuntos de cortes s\u00e3o alguns conjuntos de vari\u00e1veis que s\u00e3o cortados (cortando bordas) do gr\u00e1fico de restri\u00e7\u00f5es original e resolvidos separadamente. [9]</p> <p>O condicionamento \u00e9 o processo de atribuir um valor a alguma vari\u00e1vel em um conjunto de corte, realizar a verifica\u00e7\u00e3o progressiva em seus dom\u00ednios vizinhos antes do corte e, por fim, separ\u00e1-lo do gr\u00e1fico original. [9]</p> <p>Etapas:</p> <ul> <li> <p>Etapa 1: Escolha algum(ns) conjunto(s) de corte de vari\u00e1veis que deixe(m) um gr\u00e1fico restante estruturado em \u00e1rvore. [9]</p> </li> <li> <p>Etapa 2: Na forma tradicional de backtracking, condicione o conjunto de corte. [9]</p> </li> <li> <p>Etapa 3: Resolva o CSP estruturado em \u00e1rvore restante. [9]</p> </li> </ul>"},{"location":"problem_structure/#decomposicao-de-arvores","title":"Decomposi\u00e7\u00e3o de \u00e1rvores","text":"<p>Ideia b\u00e1sica da decomposi\u00e7\u00e3o de \u00e1rvore:</p> <ul> <li>Decompor a rede de restri\u00e7\u00f5es em subproblemas menores (sobrepostos). [10]</li> <li>Encontrar solu\u00e7\u00f5es para os subproblemas. [10]</li> <li>Criar uma solu\u00e7\u00e3o geral com base nas subsolu\u00e7\u00f5es. [10]</li> </ul> <p>Requisitos:</p> <ul> <li>Cada vari\u00e1vel do problema original aparece em pelo menos um dos n\u00f3s da \u00e1rvore. [1]</li> <li>Se duas vari\u00e1veis estiverem conectadas por uma restri\u00e7\u00e3o no problema original, elas devem aparecer juntas (junto com a restri\u00e7\u00e3o) em pelo menos um dos n\u00f3s da \u00e1rvore. [1]</li> <li>Se uma vari\u00e1vel aparecer em dois n\u00f3s da \u00e1rvore, ela dever\u00e1 aparecer em cada n\u00f3 ao longo do caminho que conecta esses n\u00f3s. [1]</li> </ul> <p>Quando tivermos um gr\u00e1fico estruturado em \u00e1rvore, poderemos aplicar o TREE-CSP-SOLVER para obter uma solu\u00e7\u00e3o em tempo O(nd<sup>2</sup>), em que n \u00e9 o n\u00famero de n\u00f3s da \u00e1rvore e d \u00e9 o tamanho do maior dom\u00ednio.</p>"},{"location":"references_first/","title":"Refer\u00eancias","text":"<ul> <li>GEEKSFORGEEKS. Problem Solving in Artificial Intelligence. Dispon\u00edvel em: https://www.geeksforgeeks.org/problem-solving-in-artificial-intelligence/#types-of-problems-in-ai. Acesso em: 30 nov. 2024. [1]</li> <li>HRIDHYA MANOJ. Problem-Solving Agents In Artificial Intelligence. Dispon\u00edvel em: https://www.skillvertex.com/blog/problem-solving-agents-in-artificial-intelligence/. Acesso em: 30 nov. 2024. [2]</li> <li>BLOG. Compara\u00e7\u00e3o entre Malha Fechada e Aberta - LMLogix Automa\u00e7\u00e3o. Dispon\u00edvel em: https://www.lmlogix.com.br/malha-fechada-e-aberta/. Acesso em: 03 dec. 2024. [3]</li> <li>Difference between Open-Loop Control System and Closed-Loop Control System. Dispon\u00edvel em: https://www.geeksforgeeks.org/difference-between-open-loop-control-system-and-closed-loop-control-system/. Acesso em: 04 dec. 2024. [4]</li> <li>RUSSELL, S. J.; NORVIG, P. Artificial Intelligence : a Modern Approach. 4th. ed. London: Pearson, 2021. [5]</li> <li>GEEKSFORGEEKS. Search Algorithms in AI - GeeksforGeeks. Dispon\u00edvel em: https://www.geeksforgeeks.org/search-algorithms-in-ai/. Acesso em: 08 dec. 2024. [6]</li> <li>Understanding AI search algorithms. Dispon\u00edvel em: https://www.elastic.co/blog/understanding-ai-search-algorithms. Acesso em: 08 dec. 2024. [7]</li> <li>D SUMATHI. Weighted A* Search-Unit-2-Artificial Intelligence-20A05502T-Solving Problems by Searching. Dispon\u00edvel em: https://www.youtube.com/watch?v=GJrq8C4wnTA. Acesso em: 18 dec. 2024. [8]</li> <li>Introduction to Beam Search Algorithm. Dispon\u00edvel em: https://www.geeksforgeeks.org/introduction-to-beam-search-algorithm/. Acesso em: 18 dec. 2024. [9]</li> <li>Iterative Deepening A algorithm (IDA) - Artificial intelligence. Dispon\u00edvel em: https://www.geeksforgeeks.org/iterative-deepening-a-algorithm-ida-artificial-intelligence/. Acesso em: 19 dec. 2024. [10]</li> <li>Introduction To The Heuristic Function In AI | Simplilearn. Dispon\u00edvel em: https://www.simplilearn.com/tutorials/artificial-intelligence-tutorial/heuristic-function-in-ai. Acesso em: 22 dec. 2024. [11]</li> <li>Ch04: Search in Complex Environment - HackMD. Dispon\u00edvel em: https://hackmd.io/@coding-guy/SJsVB8JGT?utm_source=preview-mode&amp;utm_medium=rec. Acesso em: 25 dec. 2025. [12]</li> <li>What Is Evolutionary Algorithm? | Cognizant. Dispon\u00edvel em: https://www.cognizant.com/us/en/glossary/evolutionary-algorithm. Acesso em: 28 dec. 2025. [13]</li> </ul>"},{"location":"references_first/#referencias-de-algoritmos","title":"Refer\u00eancias de algoritmos","text":""},{"location":"references_first/#busca-por-profundidade-bidirecional","title":"Busca por profundidade bidirecional","text":"<ul> <li>RAY LI CS. Mastering Bidirectional BFS with a Comprehensive Tutorial. Dispon\u00edvel em: https://www.youtube.com/watch?v=RS9r7FzYKDk. Acesso em: 01 jan. 2025.</li> <li>Word Ladder - LeetCode. Dispon\u00edvel em: https://leetcode.com/problems/word-ladder/solutions/. Acesso em: 03 jan. 2025.</li> </ul>"},{"location":"references_first/#busca-de-feixe","title":"Busca de feixe","text":"<ul> <li>HORVAT, M. Python Beam Search Algorithm \u2013 Be on the Right Side of Change. Dispon\u00edvel em: https://blog.finxter.com/python-beam-search-algorithm/. Acesso em: 04 jan. 2025.</li> <li>FINXTER. Python Beam Search Algorithm - A Simple Guide. Dispon\u00edvel em: https://www.youtube.com/watch?v=3m1lvN2fTtY. Acesso em: 04 jan. 2025.</li> </ul>"},{"location":"references_first/#escalada","title":"Escalada","text":"<ul> <li>GEEKSFORGEEKS. Hill Climbing and Simulated Annealing for the Traveling Salesman Problem. Dispon\u00edvel em: https://www.geeksforgeeks.org/hill-climbing-and-simulated-annealing-for-the-traveling-salesman-problem/. Acesso em: 07 jan. 2025.</li> </ul>"},{"location":"references_first/#algoritmo-genetico","title":"Algoritmo gen\u00e9tico","text":"<ul> <li>Genetic Algorithm In Python Super Basic Example. Dispon\u00edvel em: https://www.youtube.com/watch?v=4XZoVQOt-0I. Acesso em: 09 jan. 2025.</li> </ul>"},{"location":"references_second/","title":"Refer\u00eancias","text":"<ul> <li>RUSSELL, S. J.; NORVIG, P. Artificial Intelligence : a Modern Approach. 4th. ed. London: Pearson, 2021. [1]</li> <li>Artificial Intelligence Intelligent Agents Ansaf Salleb-Aouissi. [s.l: s.n.]. Dispon\u00edvel em: http://www.cs.columbia.edu/~ansaf/courses/4701/AI_campus_intelligent_agents.pdf. [2]</li> <li>Toolify.ai. Exploring the Types of AI Agents. Dispon\u00edvel em: https://www.toolify.ai/ai-news/exploring-the-types-of-ai-agents-44561. Acesso em: 30 dec. 2024. [3]</li> <li>How the components of agent programs work. Dispon\u00edvel em: https://www.studocu.com/row/document/jamaa%D8%A9-kfr-alshykh/artificial-intelligent/how-the-components-of-agent-programs-work/46719039?utm_source=chatgpt.com. Acesso em: 30 dec. 2024. [4]</li> <li>Constraint Satisfaction Problems (CSP) in Artificial Intelligence. Dispon\u00edvel em: https://www.geeksforgeeks.org/constraint-satisfaction-problems-csp-in-artificial-intelligence/. Acesso em: 02 jan. 2025. [5]</li> <li>Linear Constraints. Dispon\u00edvel em: https://www.lindo.com/doc/online_help/lingo15_0/linear_constraints.htm. Acesso em: 02 jan. 2025. [6]</li> <li>LINGO 15 Online Users Manual. Dispon\u00edvel em: https://www.lindo.com/doc/online_help/lingo15_0/index.html?nonlinear_constraints.htm. Acesso em: 02 jan. 2025. [7]</li> <li>GEEKSFORGEEKS. Constraint Propagation in AI. Dispon\u00edvel em: https://www.geeksforgeeks.org/constraint-propagation-in-ai/. Acesso em: 05 jan. 2025. [8]</li> <li>Andrew Forney - LMU CS. Dispon\u00edvel em: https://www.forns.lmu.build/classes/spring-2019/cmsi-282/lecture-13M.html. Acesso em: 09 jan. 2025. [9]</li> <li>HELMERT, M. Foundations of Artificial Intelligence 28. Constraint Satisfaction Problems: Decomposition Methods. [s.l: s.n.]. Dispon\u00edvel em: https://ai.dmi.unibas.ch/_files/teaching/fs19/ai/slides/ai28.pdf. Acesso em: 09 jan. 2025. [10]</li> </ul>"},{"location":"references_second/#referencias-de-algoritmos","title":"Refer\u00eancias de algoritmos","text":""},{"location":"references_second/#algoritmo-de-retrocesso","title":"Algoritmo de retrocesso:","text":"<ul> <li>Rat in a Maze Problem - I | Practice | GeeksforGeeks. Dispon\u00edvel em: https://www.geeksforgeeks.org/problems/rat-in-a-maze-problem/1?page=1. Acesso em: 09 jan. 2025.</li> </ul>"},{"location":"satisfaction_problems/","title":"Definindo Problemas de Satisfa\u00e7\u00e3o de Condi\u00e7\u00f5es","text":"<p>Um problema de satisfa\u00e7\u00e3o de condi\u00e7\u00f5es \u00e9 um problema com representa\u00e7\u00e3o factorada em que al\u00e9m de encontrar a solu\u00e7\u00e3o, os valores atribu\u00eddos \u00e0s vari\u00e1veis devem cumprir uma s\u00e9rie de restri\u00e7\u00f5es. [5] A ideia principal \u00e9 eliminar por\u00e7\u00f5es do espa\u00e7o de busca identificando combina\u00e7\u00f5es onde o valor das vari\u00e1veis viola as restri\u00e7\u00f5es. [1] Uma vantagem que eles t\u00eam \u00e9 que as a\u00e7\u00f5es que podem ser tomadas e o modelo de transi\u00e7\u00f5es (modelo que mostra a quais estados leva cada a\u00e7\u00e3o) pode ser deduzido da descri\u00e7\u00e3o do problema. [1]</p> <p>Algoritmos de problemas de satisfa\u00e7\u00e3o de condi\u00e7\u00f5es podem ser usados em:</p> <ul> <li>Programa\u00e7\u00e3o: Aloca\u00e7\u00e3o de recursos como funcion\u00e1rios ou equipes respeitando as restri\u00e7\u00f5es de tempo e disponibilidade. [5]</li> <li>Planejamento: organiza\u00e7\u00e3o de tarefas com prazos ou sequ\u00eancias espec\u00edficas. [5]</li> <li>Aloca\u00e7\u00e3o de recursos: Distribuir os recursos de forma eficiente sem us\u00e1-los em excesso. [5]</li> </ul>"},{"location":"satisfaction_problems/#componentes","title":"Componentes","text":"<ol> <li> <p>Vari\u00e1veis: S\u00e3o os objetos que devem ser avaliados para cumprir as condi\u00e7\u00f5es, alguns tipos de vari\u00e1veis s\u00e3o booleanas, inteiras e vari\u00e1veis categ\u00f3ricas. [5]</p> </li> <li> <p>Dominios: Representam o intervalo de valores poss\u00edveis que uma vari\u00e1vel pode ter, dependendo do problema os dom\u00ednios podem ser finitos ou infinitos. [5]</p> <ul> <li> <p>Dominio finito: Cont\u00e9m um n\u00famero espec\u00edfico de elementos, os quais podem ser listados em um per\u00edodo finito de tempo. [1]</p> </li> <li> <p>Dominio infinito: N\u00e3o h\u00e1 limite no n\u00famero de valores poss\u00edveis, esses valores n\u00e3o podem ser listados em um per\u00edodo de tempo limitado. Para esses dom\u00ednios, condi\u00e7\u00f5es impl\u00edcitas ex: &lt;(A,B), A &lt; B&gt; devem ser usadas em vez de valores espec\u00edficos ex: &lt;(A,B), {(0,1),(1,2),(2,3),...}&gt;. [1]</p> </li> <li> <p>Dominio discreto: Cont\u00e9m valores diferentes ex: {1, 2, 3, 4, 5}. [1]</p> </li> <li> <p>Dominio cont\u00ednuo: Consiste em um intervalo de valores poss\u00edveis, por exemplo: n\u00fameros reais no intervalo [0, 1]. [1]</p> </li> </ul> </li> <li> <p>Condi\u00e7\u00f5es: S\u00e3o guias que controlam como as vari\u00e1veis se relacionam umas com as outras, definem os poss\u00edveis valores v\u00e1lidos que as vari\u00e1veis podem ter. Condi\u00e7\u00f5es un\u00e1rias, bin\u00e1rias e de maior ordem s\u00e3o alguns exemplos de tipos de condi\u00e7\u00f5es. [5] As condi\u00e7\u00f5es s\u00e3o representadas como um par escopo, rela\u00e7\u00e3o (), onde o escopo s\u00e3o as vari\u00e1veis que participam da condi\u00e7\u00e3o e a rela\u00e7\u00e3o s\u00e3o os valores que essas vari\u00e1veis podem tomar. Ex: &lt;(X1,X2),{(3,1), (3,2), (2,1)}&gt; ou &lt;(X1,X2),X1 &gt; X2&gt;. [1]"},{"location":"satisfaction_problems/#tipos-de-condicoes","title":"Tipos de condi\u00e7\u00f5es","text":"<ol> <li> <p>Condi\u00e7\u00f5es duras e suaves: Condu\u00e7\u00f5es duras s\u00e3o aquelas que devem ser obrigatoriamente cumpridas enquanto as condi\u00e7\u00f5es suaves podem ser violadas, no entanto isso resulta em um custo adicional. [5]</p> </li> <li> <p>Condi\u00e7\u00f5es de preced\u00eancia: Determina a ordem em que as atividades dentro do problema devem ser realizadas, especificamente determina quais atividades terminam antes das outras. Ex: atividade T1 termina antes de T2 e esta demora um tempo d, a express\u00e3o da condi\u00e7\u00e3o seria esta T1 + d1 \u2264 T2. [1]</p> </li> <li> <p>Condi\u00e7\u00e3o disjuntiva: Condi\u00e7\u00f5es que obrigam a escolher apenas um valor de entre um conjunto, se A ocorre B n\u00e3o pode ocorrer e vice-versa. Ex: (AxleF +10 AxleB) ou (AxleB+10 AxleF), apenas um deles pode ser verdade, n\u00e3o ambos. [1]</p> </li> <li> <p>Condi\u00e7\u00f5es lineares: Condi\u00e7\u00f5es que n\u00e3o cont\u00eam raizes ou pot\u00eancias e cujo valor aumenta ou diminui de forma porporcional, seguem a forma aritm\u00e9tica Y = m X + b. [6]</p> </li> <li> <p>Condi\u00e7\u00f5es n\u00e3o lineares: Condi\u00e7\u00f5es que cont\u00eam raizes ou pot\u00eancias, todas as condi\u00e7\u00f5es que n\u00e3o se enquadram na defini\u00e7\u00e3o de linear s\u00e3o automaticamente n\u00e3o lineares. [7]</p> </li> <li> <p>Condi\u00e7\u00f5es un\u00e1rias: Restringe o valor de uma \u00fanica vari\u00e1vel, geralmente define que valores uma vari\u00e1vel n\u00e3o pode tomar, seja colocando limites como &gt;= ou &lt;= ou proibindo totalmente certos valores /= green. [1]</p> </li> <li> <p>Condi\u00e7\u00f5es Binarias: Restringe os valores de duas vari\u00e1veis, pode ser relacionado um com o outro A &lt;= B ou relacionados com um terceiro valor A + B = 3. [1]</p> </li> <li> <p>Condi\u00e7\u00f5es Tern\u00e1ria: Restringe os valores de tr\u00eas vari\u00e1veis, podem estar relacionadas entre si A &lt; B &lt; C ou relacionadas com um quarto valor A + B + C = 4. [1]</p> </li> <li> <p>Condi\u00e7\u00f5es globais: Restringe os valores de um n\u00famero arbitr\u00e1rio de vari\u00e1veis, este pode ser qualquer n\u00famero maior que quatro incluindo todas as vari\u00e1veis existentes no problema. Ex: Alldiff, condi\u00e7\u00e3o que estipula que todas as vari\u00e1veis devem ter valores diferentes. [1]</p> </li> <li> <p>Condi\u00e7\u00f5es de prefer\u00eancia: Condi\u00e7\u00f5es n\u00e3o obrigat\u00f3rias que ajudam a decidir quais solu\u00e7\u00f5es escolher, supondo que h\u00e1 m\u00faltiplos. Ex: em uma situa\u00e7\u00e3o se pedem dois n\u00fameros pares, o n\u00famero de op\u00e7\u00f5es foi reduzido a dois n\u00fameros 6 e 4, uma condi\u00e7\u00e3o de prefer\u00eancia \u00e9 que esse n\u00famero seja m\u00faltiplo de 3, portanto a solu\u00e7\u00e3o escolhida ser\u00e1 o n\u00famero 6; se em vez de 6 e 4 as op\u00e7\u00f5es fossem 2 e 4 ainda poderia ter sido escolhido uma solu\u00e7\u00e3o v\u00e1lida mesmo que a condi\u00e7\u00e3o n\u00e3o fosse cumprida. [1]</p> </li> </ol>"},{"location":"search-algoritms/","title":"Algoritmos de busca","text":"<p>S\u00e3o algoritmos que recebem um problema de busca como entrada e produzem uma solu\u00e7\u00e3o, estes usam algo chamado \u00e1rvore de busca, estes s\u00e3o compostos por n\u00f3s que representam um estado espec\u00edfico e as bordas que correspondem a a\u00e7\u00f5es que levam a diferentes estados; essas \u00e1rvores formam m\u00faltiplas rotas do n\u00f3 raiz que \u00e9 o estado inicial do problema, o objetivo do algoritmo de busca \u00e9 encontrar uma rota que leve ao n\u00f3 (estado) alvo. A \u00e1rvore da busca faz parte de algo conhecido como espa\u00e7o de estados, estes s\u00e3o os m\u00faltiplos e provavelmente infinitos estados que existem no mundo e as a\u00e7\u00f5es que levam de um estado para outro; o arvore de busca s\u00e3o caminhos espec\u00edficos neste espa\u00e7o de estados que se originam a partir de um \u00fanico estado raiz. [5] Em uma \u00e1rvore de busca existem dois tipos de n\u00f3s, n\u00f3s pai, que s\u00e3o os n\u00f3s a partir dos quais outros n\u00f3s s\u00e3o gerados, estes n\u00f3s gerados passam a ser chamados de n\u00f3s filhos ou sucessores. [5] A fronteira \u00e9 conhecida como a separa\u00e7\u00e3o da regi\u00e3o onde todos os n\u00f3s foram expandidos, ou seja, s\u00e3o mostrados os n\u00f3s sucessores conectados a este sem escolher nenhum e a regi\u00e3o onde est\u00e3o aqueles n\u00f3s que ainda n\u00e3o foram alcan\u00e7ados. [5]</p>"},{"location":"search-algoritms/#busca-primeiro-o-melhor","title":"Busca primeiro o melhor","text":"<p>\u00c9 uma forma de escolher qual dos n\u00f3s vai expandir, esta baseia-se em escolher o caminho que tem o menor custo poss\u00edvel, esse custo \u00e9 determinado por uma fun\u00e7\u00e3o de avalia\u00e7\u00e3o; o resultado ser\u00e1 uma indica\u00e7\u00e3o de falha ou um caminho para um n\u00f3 alvo. [5]</p>"},{"location":"search-algoritms/#estruturas-de-dados-de-busca","title":"Estruturas de dados de busca","text":""},{"location":"search-algoritms/#nos","title":"N\u00f3s","text":"<p>Para armazenar os n\u00f3s, uma estrutura de dados com quatro componentes \u00e9 usada.</p> <ul> <li>node.STATE: o estado que corresponde ao n\u00f3. [5]</li> <li>node.PARENT: o n\u00f3 que gera o n\u00f3 atual. [5]</li> <li>node.ACTION: a a\u00e7\u00e3o que foi aplicada ao n\u00f3 pai para gerar este n\u00f3. [5]</li> <li>node.PATH-COST: o custo total do caminho do n\u00f3 inicial ao atual. [5]</li> </ul>"},{"location":"search-algoritms/#fronteira","title":"Fronteira","text":"<p>Para armazenar a fronteira \u00e9 usada uma fila, as opera\u00e7\u00f5es nessa fronteira s\u00e3o:</p> <ul> <li>IS-EMPTY(frontier): s\u00f3 retorna True quando n\u00e3o h\u00e1 n\u00f3s na fronteira. [5]</li> <li>POP(frontier): remove o n\u00f3 superior da fronteira e apresenta-lo. [5]</li> <li>TOP(frontier): apresenta, mas n\u00e3o elimina, o n\u00f3 superior da fronteira. [5]</li> <li>ADD(node, frontier): insere um n\u00f3 na fronteira. [5]</li> </ul>"},{"location":"search-algoritms/#tipos-de-filas","title":"Tipos de filas","text":"<ul> <li>Fila de prioridade: o primeiro n\u00f3 que usar a fun\u00e7\u00e3o POP ser\u00e1 aquele com o custo m\u00ednimo determinado pela fun\u00e7\u00e3o de avalia\u00e7\u00e3o. [5]</li> <li>Fila FIFO: o primeiro n\u00f3 a ser usado pela fun\u00e7\u00e3o POP, ser\u00e1 aquele que foi inserido primeiro na fila. [5]</li> <li>Fila LIFO: o primeiro n\u00f3 a ser usado pela fun\u00e7\u00e3o POP ser\u00e1 aquele que foi inserido mais recentemente na fila. [5]</li> </ul>"},{"location":"search-algoritms/#medir-el-rendimiento-en-la-resolucion-de-problemas","title":"Medir el rendimiento en la resoluci\u00f3n de problemas","text":"<p>Crit\u00e9rio utilizado para escolher algoritmos de busca, o desempenho pode ser medido em quatro formas:</p> <ul> <li>Completude: O algoritmo pode encontrar uma solu\u00e7\u00e3o ou relatar sua falha quando n\u00e3o h\u00e1 uma? O algoritmo deve ser capaz, independentemente do tamanho do espa\u00e7o, chegar a um estado que esteja conectado com o estado inicial. [5]</li> <li>Otimiza\u00e7\u00e3o de custos: Pode encontrar uma solu\u00e7\u00e3o com o menor custo de todas as solu\u00e7\u00f5es? [5] </li> <li>Complexidade de tempo: Quanto tempo leva para encontrar uma solu\u00e7\u00e3o. Pode ser medido em uma unidade de tempo como segundos ou pelo n\u00famero de a\u00e7\u00f5es e estados. [5]</li> <li>Complexidade do espa\u00e7o: Quanta mem\u00f3ria \u00e9 usada para fazer a busca. [5]</li> </ul>"},{"location":"search-algoritms/#busca-cega","title":"Busca cega","text":"<p>Algoritmos que n\u00e3o possuem informa\u00e7\u00f5es sobre o espa\u00e7o de busca, dependem unicamente da estrutura do espa\u00e7o de busca para encontrar uma solu\u00e7\u00e3o. [5] Eles s\u00e3o apenas capazes de gerar sucessores e diferenciar entre o estado objetivo e n\u00e3o-objetivo. Os planos para chegar ao estado-alvo a partir do estado inicial s\u00e3o diferenciados apenas pela ordem e dura\u00e7\u00e3o das a\u00e7\u00f5es. [6]</p>"},{"location":"search-algoritms/#busca-por-amplitude","title":"Busca por amplitude","text":"<p>Estrat\u00e9gia apropriada quando todas as a\u00e7\u00f5es t\u00eam o mesmo custo, baseia-se em expandir primeiro todos os n\u00f3s pai antes de expandir seus sucessores, come\u00e7ando com o n\u00f3 raiz. \u00c9 uma estrat\u00e9gia de busca sistem\u00e1tica, ent\u00e3o funciona mesmo em espa\u00e7os de estados infinitos. A fun\u00e7\u00e3o de avalia\u00e7\u00e3o \u00e9 o n\u00famero de a\u00e7\u00f5es que s\u00e3o tomadas para chegar a um n\u00f3. Para essa estrat\u00e9gia, uma fila FIFO \u00e9 usada, onde os novos n\u00f3s v\u00e3o para o final da fila e os mais antigos ficam no in\u00edcio. Essa estrat\u00e9gia permite verificar se um estado \u00e9 o alvo antes que ele saia da fila, porque uma vez que um estado foi atingido n\u00e3o ser\u00e1 poss\u00edvel encontrar um caminho melhor. Busca por profundidade sempre encontra uma solu\u00e7\u00e3o com o menor n\u00famero de a\u00e7\u00f5es pois esta gera todos os n\u00f3s em um \"n\u00edvel\" antes de passar ao pr\u00f3ximo pelo que se a solu\u00e7\u00e3o estiver nesse \"n\u00edvel\" j\u00e1 teria sido encontrada. Esta estrat\u00e9gia possui uma complexidade de tempo e espa\u00e7o de O(b<sup>d</sup>) onde b s\u00e3o os n\u00f3s sucessores e d \u00e9 a profundidade da \u00e1rvore de busca. [5]</p> <p></p> <p>Exemplo de problema a ser resolvido onde se deve ir de S para G.</p> <p></p> <p>Solu\u00e7\u00e3o BFS para o problema.</p>"},{"location":"search-algoritms/#algoritmo-de-dijkstra","title":"Algoritmo de Dijkstra","text":"<p>Tamb\u00e9m conhecido como busca de custo uniforme \u00e9 usado quando as a\u00e7\u00f5es t\u00eam custos diferentes, baseia-se em expandir primeiro o estado que tem o menor custo, esses custos s\u00e3o atribu\u00eddos com base no custo que t\u00eam todas as a\u00e7\u00f5es tomadas para chegar a esse estado. Se durante o processo for encontrado um caminho com menor custo para um estado que j\u00e1 havia sido alcan\u00e7ado, este caminho substituir\u00e1 o anterior. A complexidade do algoritmo de Dijkstra \u00e9 de O(b<sup>1 + [C/e]) onde C \u00e9 o custo da solu\u00e7\u00e3o ideal, e \u00e9 o custo m\u00ednimo de uma a\u00e7\u00e3o com e &gt; 0 e b \u00e9 o n\u00famero de vizinhos por n\u00f3. Esta estrat\u00e9gia \u00e9 completa e de custo \u00f3timo, pois a primeira solu\u00e7\u00e3o que encontrar ter\u00e1 um custo t\u00e3o baixo quanto o custo de qualquer outro n\u00f3. [5] <p></p> <p>Exemplo de problema a ser resolvido onde se deve ir de S para G.</p> <p></p> <p>Solu\u00e7\u00e3o para o problema usando algoritmo dijkstra.</p>"},{"location":"search-algoritms/#busca-por-profundidade","title":"Busca por profundidade","text":"<p>Esta estrat\u00e9gia \u00e9 baseada em expandir primeiro os n\u00f3s sucessores antes de expandir os n\u00f3s pai, nesta mente automaticamente \"abaixa\" tudo o que pode na \u00e1rvore de busca at\u00e9 encontrar um n\u00f3 que n\u00e3o tenha sucessores, Ent\u00e3o, um n\u00edvel \u00e9 elevado e verifica se o n\u00f3 pai tem outros n\u00f3s sucessores n\u00e3o expandidos, se este for o caso, passa a expandir estes. Esta estrat\u00e9gia n\u00e3o \u00e9 eficaz em custo, pois retorna a primeira solu\u00e7\u00e3o que encontra. Somente \u00e9 eficaz em espa\u00e7os finitos que s\u00e3o \u00e1rvores, em espa\u00e7os c\u00edclicos pode ficar presa em um loop infinito e em espa\u00e7os infinitos \u00e9 poss\u00edvel que termine presa em um caminho infinito mesmo n\u00e3o havendo ciclos, pelo que n\u00e3o \u00e9 sistem\u00e1tica. Uma das suas principais vantagens e a principal raz\u00e3o pela qual \u00e9 usado \u00e9 a baixa quantidade de mem\u00f3ria necess\u00e1ria. Sua complexidade espacial, somente em espa\u00e7os onde \u00e9 aplic\u00e1vel, \u00e9 de O(bm) onde b \u00e9 o fator de ramifica\u00e7\u00e3o (n\u00famero de filhos em cada n\u00f3) e m \u00e9 a profundidade m\u00e1xima da \u00e1rvore. [5]</p> <p></p> <p>Exemplo de problema a ser resolvido onde se deve ir de S para G.</p> <p></p> <p>Solu\u00e7\u00e3o DFS para o problema.</p>"},{"location":"search-algoritms/#busca-por-profundidade-limitada","title":"Busca por profundidade limitada","text":"<p>\u00c9 uma vers\u00e3o de busca por profundidade na qual os n\u00f3s que est\u00e3o em uma profundidade l definida anteriormente, ser\u00e3o considerados como se n\u00e3o tivessem sucessores. Isso \u00e9 feito com o objetivo de que a busca por profundidade n\u00e3o fique presa em um caminho infinito. A complexidade do espa\u00e7o \u00e9 O(b<sup>l</sup>) enquanto que a complexidade do tempo \u00e9 O(bl) onde b \u00e9 o fator de ramifica\u00e7\u00e3o (n\u00famero de filhos em cada n\u00f3) e l \u00e9 a profundidade limite. Escolher o limite certo \u00e9 muito importante, pois disso depende que o algoritmo possa alcan\u00e7ar a solu\u00e7\u00e3o. Para aumentar a qualidade do limite definido pode-se usar informa\u00e7\u00e3o que est\u00e1 dispon\u00edvel sobre o problema. Uma maneira bastante simples de definir esse limite \u00e9 o n\u00famero de n\u00f3s na \u00e1rvore menos um; no entanto, uma forma muito mais eficaz que \u00e9 usar o di\u00e2metro do grafo, este \u00e9 o caminho mais curto entre os n\u00f3s mais distantes no grafo. Infelizmente, na maioria dos casos, informa\u00e7\u00f5es como o di\u00e2metro n\u00e3o estar\u00e3o dispon\u00edveis at\u00e9 que o problema seja resolvido. [5]</p>"},{"location":"search-algoritms/#busca-iterativa-de-aprofundamento","title":"Busca iterativa de aprofundamento","text":"<p>Vers\u00e3o do algoritmo usado como solu\u00e7\u00e3o para o problema de encontrar um limite apropriado l, isso \u00e9 feito executando o algoritmo usando cada valor poss\u00edvel, come\u00e7ando de zero, at\u00e9 que uma solu\u00e7\u00e3o seja encontrada ou at\u00e9 que uma falha seja retornado. Seu uso \u00e9 \u00f3timo quando as a\u00e7\u00f5es custam o mesmo e \u00e9 completo em espa\u00e7os finitos sem ciclos ou quando os n\u00f3s s\u00e3o verificados para ciclos ao longo do caminho. Os requisitos de mem\u00f3ria n\u00e3o s\u00e3o t\u00e3o altos sendo sua complexidade espacial O(bd) se houver solu\u00e7\u00e3o ou O(bm) em espa\u00e7os finitos onde n\u00e3o h\u00e1. Isso \u00e9 conseguido porque este algoritmo opta por gerar todos os n\u00f3s novamente para cada itera\u00e7\u00e3o em vez de mant\u00ea-los na mem\u00f3ria, no entanto, isto resulta em um aumento no tempo de execu\u00e7\u00e3o. A complexidade do tempo \u00e9 O(b<sup>d</sup>) quando h\u00e1 solu\u00e7\u00e3o ou O(b<sup>m</sup>) quando n\u00e3o h\u00e1. Para as complexidades b \u00e9 o fator de ramifica\u00e7\u00e3o (n\u00famero de filhos em cada n\u00f3), m \u00e9 a profundidade m\u00e1xima (que aumenta em cada itera\u00e7\u00e3o) e d \u00e9 a profundidade onde o alvo est\u00e1. [5]</p> <p></p> <p>Exemplo de algoritmo DFS iterativo.</p>"},{"location":"search-algoritms/#busca-bidirecional","title":"Busca bidirecional","text":"<p>Algoritmo no qual s\u00e3o feitas duas buscas ao mesmo tempo, uma do n\u00f3 raiz e outra do n\u00f3 alvo, isto com a inten\u00e7\u00e3o de que as duas buscas se encontrem para assim chegar \u00e0 solu\u00e7\u00e3o. Para que isso funcione corretamente \u00e9 necess\u00e1rio manter duas tabelas de n\u00f3s a que se chegou, duas fronteiras e ser capaz de raciocinar ao contr\u00e1rio (os pap\u00e9is de n\u00f3 pai e sucessor s\u00e3o invertidos quando vistos da perspectiva do outro busqueda). Para saber qual n\u00f3 expandir usa a fun\u00e7\u00e3o de avalia\u00e7\u00e3o, expande o n\u00f3 que tem o menor valor entre as duas fronteiras. A complexidade de tempo e espa\u00e7o \u00e9 O(b<sup>d/2</sup>) onde b \u00e9 o fator de ramifica\u00e7\u00e3o (n\u00famero de filhos em cada n\u00f3) e d \u00e9 a profundidade onde o alvo est\u00e1. [5]</p>"},{"location":"search-algoritms/#exemplo-de-implementacao-de-busca-cega","title":"Exemplo de implementa\u00e7\u00e3o de busca cega","text":"<p>Algoritmo que usa BFS bidirecional para resolver um problema de escada de palavras. Tenta converter uma palavra em outra. Neste exemplo, voc\u00ea s\u00f3 pode usar palavras que est\u00e3o na lista e uma palavra s\u00f3 pode ser convertida em outra se a diferen\u00e7a for de uma letra.</p> <pre><code>\nfrom collections import deque\n\ndef word_ladder_bidirectional_bfs(begin_word, end_word, word_list):\n\n    if end_word not in word_list:\n        return 0\n\n    word_list = set(word_list)\n    word_list.add(begin_word)\n\n    begin_queue = deque([(begin_word, 1)])\n    end_queue = deque([(end_word, 1)])\n\n    begin_visited = {begin_word: 1}\n    end_visited = {end_word: 1}\n\n    while begin_queue and end_queue:\n        result = bfs_step(begin_queue, begin_visited, end_visited, word_list)\n        if result:\n            return result\n\n        result = bfs_step(end_queue, end_visited, begin_visited, word_list)\n        if result:\n            return result\n\n    return 0\n\ndef bfs_step(queue, visited, other_visited, word_list):\n\n    current_word, level = queue.popleft()\n\n    for i in range(len(current_word)):\n        for char in 'abcdefghijklmnopqrstuvwxyz':\n            transformed_word = current_word[:i] + char + current_word[i+1:]\n\n            if transformed_word in word_list:\n                if transformed_word in other_visited:\n                    return level + other_visited[transformed_word]\n\n                if transformed_word not in visited:\n                    visited[transformed_word] = level + 1\n                    queue.append((transformed_word, level + 1))\n\n    return None\n\nif __name__ == \"__main__\":\n\n    word_list = [\"hot\", \"dot\", \"dog\", \"lot\", \"log\", \"cog\"]\n\n    print(\"Words in word list: \")\n\n    for word in word_list:\n        print(word)\n\n    begin_word = \"hit\"\n    end_word = \"cog\"\n\n    result = word_ladder_bidirectional_bfs(begin_word, end_word, word_list)\n\n    if result:\n        print(f\"The shortest transformation sequence length is: {result}\")\n    else:\n        print(\"No valid transformation sequence exists.\")\n\n</code></pre>"},{"location":"search-algoritms/#busca-informada","title":"Busca informada","text":"<p>Algoritmos que t\u00eam informa\u00e7\u00f5es no estado alvo que usam para aumentar a efic\u00e1cia dos buscas. Esta informa\u00e7\u00e3o vem na forma de heur\u00edsticas que s\u00e3o fun\u00e7\u00f5es usadas para estimar a dist\u00e2ncia do estado alvo que ajudam a priorizar caminhos e n\u00e3o realizar explora\u00e7\u00f5es desnecess\u00e1rias. Alguns exemplos de heuristicas s\u00e3o a dist\u00e2ncia de Manhattan e a dist\u00e2ncia euclidiana. Diferentes heur\u00edsticas s\u00e3o usadas dependendo do algoritmo que ser\u00e1 implementado. [6]</p>"},{"location":"search-algoritms/#greedy-melhor-primeira-busca","title":"Greedy melhor-primeira busca","text":"<p>Uma forma de busca do melhor primeiro em que primeiro se expande o n\u00f3 mais pr\u00f3ximo ao alvo, esta dist\u00e2ncia pode ser expandida usando uma heur\u00edstica h(x) expandindo o n\u00f3 com o menor valor dado por essa heur\u00edstica. Este algoritmo \u00e9 completo em espa\u00e7os finitos, mas n\u00e3o em espa\u00e7os infinitos. Complexidade de espa\u00e7o e tempo no mas dos casos \u00e9 O(|V|), sem embrago com uma boa heur\u00edstica a complexidade pode ser reduzida at\u00e9 O(bm) em certos problemas. Para escolher uma boa heur\u00edstica \u00e9 necess\u00e1rio ter uma quantidade de informa\u00e7\u00f5es sobre o ambiente, qual heur\u00edstica ser\u00e1 usada depende do problema em quest\u00e3o. Um exemplo de heur\u00edstica seria a dist\u00e2ncia da linha reta, que est\u00e1 relacionada \u00e0 dist\u00e2ncia real dos caminhos. [5]</p>"},{"location":"search-algoritms/#busca-a","title":"Busca A\u2217","text":"<p>Estrat\u00e9gia que combina busca de custo uniforme e busca gananciosa, primeiro expande o n\u00f3 que tem o menor valor f(n) que \u00e9 calculado somando g(n), custo regressivo que \u00e9 o custo do n\u00f3 inicial at\u00e9 o n\u00f3 atual n, com h(n), custo futuro que \u00e9 o menor custo estimado do n\u00f3 atual para o n\u00f3 alvo. [6] A complexidade depende da heur\u00edstica usada, no pior dos casos esta ser\u00e1 igual \u00e0 de busca de custo uniforme. A efic\u00e1cia desta busca depende de que a heur\u00edstica seja admiss\u00edvel, ou seja, n\u00e3o superestime o custo real de alcan\u00e7ar o n\u00f3 alvo. Uma das principais desvantagens \u00e9 o alto consumo de tempo e espa\u00e7o de mem\u00f3ria, pois muitos n\u00f3s s\u00e3o expandidos. [5]</p> <p></p> <p>Custo de chegar a cada n\u00f3 para o exemplo de algoritmo de busca A\u2217.</p> <p></p> <p>Exemplo de algoritmo de busca A\u2217.</p>"},{"location":"search-algoritms/#busca-a-ponderada","title":"Busca A\u2217 ponderada","text":"<p>Varia\u00e7\u00e3o de busca A em que se introduz um peso na f\u00f3rmula f(n) ficando assim f(n) = g(n) + Wh(n), onde W seria o peso do n\u00f3, este sempre deve ser maior que um e seu valor aumentar\u00e1 quanto mais pr\u00f3ximo este dito n\u00f3 do n\u00f3 alvo, Isso permite que o algoritmo explore os n\u00f3s que podem ter um valor h(n) baixo. Este algoritmo s\u00f3 deve ser aplicado se voc\u00ea pode aceitar solu\u00e7\u00f5es sub\u00f3timas, pois n\u00e3o garante o menor custo poss\u00edvel, em troca consome menos espa\u00e7o e encontra uma solu\u00e7\u00e3o em menos tempos porque expande menos n\u00f3s. A complexidade \u00e9 bastante semelhante \u00e0 busca A* com v\u00e1rias varia\u00e7\u00f5es. [8]</p> <p></p> <p>Compara\u00e7\u00e3o de busca A\u2217 (a) com Busca A\u2217 ponderada (b). As barras cinzas s\u00e3o obst\u00e1culos, a linha roxa \u00e9 o caminho do in\u00edcio verde at\u00e9 a meta vermelha, e os pequenos pontos s\u00e3o estados que foram alcan\u00e7ados por cada busca.</p>"},{"location":"search-algoritms/#busca-de-feixe","title":"Busca de feixe","text":"<p>Algoritmo de busca com funcionalidade similar \u00e0 busca por profundidade, j\u00e1 que gera todos os sucessores em um n\u00edvel, por\u00e9m neste caso limitamos os n\u00f3s que podem ser expandidos, s\u00f3 considerando aqueles que t\u00eam os melhores valores dados pela heur\u00edstica. O n\u00famero de n\u00f3s que podem expandir \u00e9 conhecido como a largura do raio (W) que \u00e9 definida manualmente. Para saber quantos n\u00f3s ser\u00e3o avaliados, multiplique-se a largura do feixe pelo fator de ramifica\u00e7\u00e3o W * B. [9] Este algoritmo \u00e9 incompleto e sub\u00f3timo, pois n\u00e3o garante a solu\u00e7\u00e3o com menos custo em troca de executar extremamente r\u00e1pido e consumir muito menos mem\u00f3ria porque expande menos n\u00f3s. Na pr\u00e1tica, ele \u00e9 capaz de encontrar solu\u00e7\u00f5es muito pr\u00f3ximas das \u00f3timas para muitos problemas. Essa efic\u00e1cia depende muito da qualidade da heur\u00edstica. Complexidade do tempo \u00e9 O(bW) e complexidade do espa\u00e7o \u00e9 O(mW*b) onde b \u00e9 o fator de ramifica\u00e7\u00e3o (n\u00famero de filhos em cada n\u00f3), m \u00e9 a profundidade m\u00e1xima e W \u00e9 a largura do raio. [5]</p> <p></p> <p>\u00c1rvore de busca de feixe, com W = 2 e B = 3 - Apenas dois n\u00f3s (n\u00f3s pretos) s\u00e3o selecionados com base em seus valores heur\u00edsticos para expans\u00e3o adicional em cada n\u00edvel</p>"},{"location":"search-algoritms/#busca-a-com-aprofundamento-iterativo","title":"Busca A\u2217 com aprofundamento iterativo","text":"<p>Algoritmo que combina recursos de busca por profundidade iterativa com a busca A. [10] Limita o uso de mem\u00f3ria ao n\u00e3o salvar os n\u00f3s visitados, isso faz com que eles sejam visitados novamente em cada itera\u00e7\u00e3o. [5] O n\u00famero de n\u00f3s expandidos depende do valor de f(n), isto \u00e9 feito expandindo os n\u00f3s at\u00e9 chegar a um com um valor f(n) maior que um limite definido, a itera\u00e7\u00e3o termina quando se chega a todos os n\u00f3s com valores maiores que o limite. O valor limite aumenta a cada itera\u00e7\u00e3o. O valor f(n) \u00e9 calculado g(n) + h(n). Este algoritmo garante encontrar a solu\u00e7\u00e3o com o menor custo poss\u00edvel, al\u00e9m de tamb\u00e9m funciona em espa\u00e7os infinitos tudo isso com um uso limitado de mem\u00f3ria, em troca \u00e9 mais lento que procura A pois tem que percorrer todos os n\u00f3s em cada itera\u00e7\u00e3o, at\u00e9 mesmo de exigir maior poder de processamento. [!0]</p> <p></p> <p>Primeira itera\u00e7\u00e3o do algoritmo de busca A\u2217 com aprofundamento iterativa.</p> <p></p> <p>Segunda itera\u00e7\u00e3o do algoritmo de busca A\u2217 com aprofundamento iterativa.</p> <p></p> <p>Terceira itera\u00e7\u00e3o do algoritmo de busca A\u2217 com aprofundamento iterativa.</p> <p></p> <p>Quarta itera\u00e7\u00e3o do algoritmo de busca A\u2217 com aprofundamento iterativa.</p> <p></p> <p>Quinta itera\u00e7\u00e3o do algoritmo de busca A\u2217 com aprofundamento iterativa.</p> <p></p> <p>Sexta itera\u00e7\u00e3o do algoritmo de busca A\u2217 com aprofundamento iterativa.</p>"},{"location":"search-algoritms/#busca-recursiva-do-melhor-primeiro","title":"Busca recursiva do melhor primeiro","text":"<p>Algoritmo com funcionalidade semelhante \u00e0 busca do melhor primeiro, no entanto este tem a capacidade de \"retroceder\" se considerar que o caminho atual n\u00e3o \u00e9 o melhor e existe uma alternativa que poderia dar melhores resultados. Isso \u00e9 feito usando um valor f que serve como limite, se um n\u00f3 atinge esse valor \u00e9 retornado para seu antepassado, substitui o valor do limite pelo do n\u00f3 e expande-se um n\u00f3 alternativo que tenha o melhor valor f(n). Este algoritmo \u00e9 \u00f3timo se a heur\u00edstica h(n) for admiss\u00edvel, ou seja, n\u00e3o superestime o custo real de alcan\u00e7ar o n\u00f3 alvo. A complexidade espacial \u00e9 linear \u00e0 profundidade da solu\u00e7\u00e3o com menor custo mais profunda, a complexidade de tempo varia muito, depende principalmente da precis\u00e3o da fun\u00e7\u00e3o heur\u00edstica e quantas vezes se muda de caminho. [5]</p>"},{"location":"search-algoritms/#pesquisa-heuristica-bidirecional","title":"Pesquisa heur\u00edstica bidirecional","text":"<p>Algoritmo que implementa a funcionalidade de busca bidirecional com uma f\u00f3rmula heur\u00edstica para determinar qual n\u00f3 ser\u00e1 expandido entre as duas fronteiras. Uma maneira de fazer isso seria usando a f\u00f3rmula de busca A f (n) = g(n) + h(n), no entanto para que isso funcione a heur\u00edstica dessa f\u00f3rmula deve ser diferente para cada um dos dois busques que s\u00e3o feitos, porque ambos t\u00eam objetivos diferentes uma tenta ir para o objetivo e outra para a origem, por isso devem ser usadas duas f\u00f3rmulas distintas fF(n) =gF(n) + hF(n) para busca que vai para o alvo e fB(n) = gB(n) + hB(n) para busca que vai para o n\u00f3 raiz. Outra forma que pode ser feita \u00e9 usando a f\u00f3rmula f2(n) = max(2g(n),g(n)+h(n)), esta ao contr\u00e1rio da f\u00f3rmula de busca A pode ser usada para ambos os busses, expande-se o n\u00f3 que tem o valor m\u00ednimo f2(n). Sua efic\u00e1cia depende da qualidade da heur\u00edstica, se essa heur\u00edstica \u00e9 boa busca A* d\u00e1 melhores resultados, se a qualidade \u00e9 regular procura bidirecional \u00e9 preferida porque explora menos n\u00f3s e se a heur\u00edstica \u00e9 m\u00e1 ambas t\u00eam um desempenho quase igual. Este algoritmo \u00e9 completo e \u00f3timo. [5]</p>"},{"location":"search-algoritms/#exemplo-de-implementacao-de-busca-informada","title":"Exemplo de implementa\u00e7\u00e3o de busca informada","text":"<p>Algoritmo que usa beam search para encontrar os b (neste caso 3) melhores caminhos no grafo (caminhos com menor custo). Isto \u00e9, b \u00e9 a largura do raio, assim como tamb\u00e9m \u00e9 o valor limite. Para este exemplo, assume-se que todos os n\u00f3s est\u00e3o conectados a todos os outros n\u00f3s. As posi\u00e7\u00f5es na matriz s\u00e3o os n\u00f3s e os n\u00fameros em cada posi\u00e7\u00e3o \u00e9 o custo de chegar a esse n\u00f3.</p> <pre><code>\nfrom numpy import array\n\n\ndef beam_search(distances, beta):\n    paths_so_far = [[list(), 0]]\n\n    for idx, tier in enumerate(distances):\n        if idx &gt; 0:\n            print(f'Paths kept after tier {idx-1}:')\n            print(*paths_so_far, sep='\\n')\n        paths_at_tier = list()\n\n        for i in range(len(paths_so_far)):\n            path, distance = paths_so_far[i]\n\n\n            for j in range(len(tier)):\n                path_extended = [path + [j], distance + tier[j]]\n                paths_at_tier.append(path_extended)\n\n        paths_ordered = sorted(paths_at_tier, key=lambda element: element[1])\n\n        paths_so_far = paths_ordered[:beta]\n        print(f'\\nPaths pruned after tier {idx}: ')\n        print(*paths_ordered[beta:], sep='\\n')\n\n    return paths_so_far\n\n\ndists = [[1, 3, 2, 5, 8],\n         [4, 7, 9, 6, 7]]\ndists = array(dists)\n\nbest_beta_paths = beam_search(dists, 3)\n\nprint('\\nThe best \\'beta\\' paths:')\nfor beta_path in best_beta_paths:\n    print(beta_path)\n\n</code></pre>"}]}
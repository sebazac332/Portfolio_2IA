
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../open-closed-problems/">
      
      
        <link rel="next" href="../heuristic_functions/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.49">
    
    
      
        <title>Algoritmos de busca - Portfólio 2 e 3 de Inteligência Artificial</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.6f8fc17f.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#algoritmos-de-busca" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Portfólio 2 e 3 de Inteligência Artificial" class="md-header__button md-logo" aria-label="Portfólio 2 e 3 de Inteligência Artificial" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Portfólio 2 e 3 de Inteligência Artificial
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Algoritmos de busca
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="blue" data-md-color-accent="indigo"  aria-label="Dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Portfólio 2 e 3 de Inteligência Artificial" class="md-nav__button md-logo" aria-label="Portfólio 2 e 3 de Inteligência Artificial" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Portfólio 2 e 3 de Inteligência Artificial
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Impressões gerais
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Portfólio 2
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Portfólio 2
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../problem_solution_agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agentes de soluções de problemas
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../open-closed-problems/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Problemas de malha aberta e de malha fechada
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Algoritmos de busca
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Algoritmos de busca
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#busca-primeiro-o-melhor" class="md-nav__link">
    <span class="md-ellipsis">
      Busca primeiro o melhor
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#estruturas-de-dados-de-busca" class="md-nav__link">
    <span class="md-ellipsis">
      Estruturas de dados de busca
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Estruturas de dados de busca">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#nos" class="md-nav__link">
    <span class="md-ellipsis">
      Nós
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fronteira" class="md-nav__link">
    <span class="md-ellipsis">
      Fronteira
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tipos-de-filas" class="md-nav__link">
    <span class="md-ellipsis">
      Tipos de filas
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#medir-el-rendimiento-en-la-resolucion-de-problemas" class="md-nav__link">
    <span class="md-ellipsis">
      Medir el rendimiento en la resolución de problemas
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#busca-cega" class="md-nav__link">
    <span class="md-ellipsis">
      Busca cega
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Busca cega">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#busca-por-amplitude" class="md-nav__link">
    <span class="md-ellipsis">
      Busca por amplitude
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#algoritmo-de-dijkstra" class="md-nav__link">
    <span class="md-ellipsis">
      Algoritmo de Dijkstra
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-por-profundidade" class="md-nav__link">
    <span class="md-ellipsis">
      Busca por profundidade
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-por-profundidade-limitada" class="md-nav__link">
    <span class="md-ellipsis">
      Busca por profundidade limitada
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-iterativa-de-aprofundamento" class="md-nav__link">
    <span class="md-ellipsis">
      Busca iterativa de aprofundamento
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-bidirecional" class="md-nav__link">
    <span class="md-ellipsis">
      Busca bidirecional
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exemplo-de-implementacao-de-busca-cega" class="md-nav__link">
    <span class="md-ellipsis">
      Exemplo de implementação de busca cega
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#busca-informada" class="md-nav__link">
    <span class="md-ellipsis">
      Busca informada
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Busca informada">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#greedy-melhor-primeira-busca" class="md-nav__link">
    <span class="md-ellipsis">
      Greedy melhor-primeira busca
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-a" class="md-nav__link">
    <span class="md-ellipsis">
      Busca A∗
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-a-ponderada" class="md-nav__link">
    <span class="md-ellipsis">
      Busca A∗ ponderada
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-de-feixe" class="md-nav__link">
    <span class="md-ellipsis">
      Busca de feixe
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-a-com-aprofundamento-iterativo" class="md-nav__link">
    <span class="md-ellipsis">
      Busca A∗ com aprofundamento iterativo
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-recursiva-do-melhor-primeiro" class="md-nav__link">
    <span class="md-ellipsis">
      Busca recursiva do melhor primeiro
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pesquisa-heuristica-bidirecional" class="md-nav__link">
    <span class="md-ellipsis">
      Pesquisa heurística bidirecional
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exemplo-de-implementacao-de-busca-informada" class="md-nav__link">
    <span class="md-ellipsis">
      Exemplo de implementação de busca informada
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../heuristic_functions/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Funções Heurísticas
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../complex_search/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Busca em ambientes complexos
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../genetic_algoritms/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Algoritmos genéticos
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../conclusion_first/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Conclusão
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../references_first/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Referências
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Portfólio 3
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Portfólio 3
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../atomic_vs_factored/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Representação Atômica vs. Fatorada
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../satisfaction_problems/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Definindo Problemas de Satisfação de Condições
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../CSP_algorithms/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Algoritmos
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../problem_structure/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Estrutura de problemas
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../conclusion_second/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Conclusão
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../references_second/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Referências
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#busca-primeiro-o-melhor" class="md-nav__link">
    <span class="md-ellipsis">
      Busca primeiro o melhor
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#estruturas-de-dados-de-busca" class="md-nav__link">
    <span class="md-ellipsis">
      Estruturas de dados de busca
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Estruturas de dados de busca">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#nos" class="md-nav__link">
    <span class="md-ellipsis">
      Nós
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fronteira" class="md-nav__link">
    <span class="md-ellipsis">
      Fronteira
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tipos-de-filas" class="md-nav__link">
    <span class="md-ellipsis">
      Tipos de filas
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#medir-el-rendimiento-en-la-resolucion-de-problemas" class="md-nav__link">
    <span class="md-ellipsis">
      Medir el rendimiento en la resolución de problemas
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#busca-cega" class="md-nav__link">
    <span class="md-ellipsis">
      Busca cega
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Busca cega">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#busca-por-amplitude" class="md-nav__link">
    <span class="md-ellipsis">
      Busca por amplitude
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#algoritmo-de-dijkstra" class="md-nav__link">
    <span class="md-ellipsis">
      Algoritmo de Dijkstra
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-por-profundidade" class="md-nav__link">
    <span class="md-ellipsis">
      Busca por profundidade
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-por-profundidade-limitada" class="md-nav__link">
    <span class="md-ellipsis">
      Busca por profundidade limitada
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-iterativa-de-aprofundamento" class="md-nav__link">
    <span class="md-ellipsis">
      Busca iterativa de aprofundamento
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-bidirecional" class="md-nav__link">
    <span class="md-ellipsis">
      Busca bidirecional
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exemplo-de-implementacao-de-busca-cega" class="md-nav__link">
    <span class="md-ellipsis">
      Exemplo de implementação de busca cega
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#busca-informada" class="md-nav__link">
    <span class="md-ellipsis">
      Busca informada
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Busca informada">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#greedy-melhor-primeira-busca" class="md-nav__link">
    <span class="md-ellipsis">
      Greedy melhor-primeira busca
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-a" class="md-nav__link">
    <span class="md-ellipsis">
      Busca A∗
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-a-ponderada" class="md-nav__link">
    <span class="md-ellipsis">
      Busca A∗ ponderada
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-de-feixe" class="md-nav__link">
    <span class="md-ellipsis">
      Busca de feixe
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-a-com-aprofundamento-iterativo" class="md-nav__link">
    <span class="md-ellipsis">
      Busca A∗ com aprofundamento iterativo
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#busca-recursiva-do-melhor-primeiro" class="md-nav__link">
    <span class="md-ellipsis">
      Busca recursiva do melhor primeiro
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pesquisa-heuristica-bidirecional" class="md-nav__link">
    <span class="md-ellipsis">
      Pesquisa heurística bidirecional
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#exemplo-de-implementacao-de-busca-informada" class="md-nav__link">
    <span class="md-ellipsis">
      Exemplo de implementação de busca informada
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="algoritmos-de-busca">Algoritmos de busca</h1>
<p>São algoritmos que recebem um problema de busca como entrada e produzem uma solução, estes usam algo chamado árvore de busca, estes são compostos por nós que representam um estado específico e as bordas que correspondem a ações que levam a diferentes estados; essas árvores formam múltiplas rotas do nó raiz que é o estado inicial do problema, o objetivo do algoritmo de busca é encontrar uma rota que leve ao nó (estado) alvo.
A árvore da busca faz parte de algo conhecido como espaço de estados, estes são os múltiplos e provavelmente infinitos estados que existem no mundo e as ações que levam de um estado para outro; o arvore de busca são caminhos específicos neste espaço de estados que se originam a partir de um único estado raiz. [5]
Em uma árvore de busca existem dois tipos de nós, nós pai, que são os nós a partir dos quais outros nós são gerados, estes nós gerados passam a ser chamados de nós filhos ou sucessores. [5]
A fronteira é conhecida como a separação da região onde todos os nós foram expandidos, ou seja, são mostrados os nós sucessores conectados a este sem escolher nenhum e a região onde estão aqueles nós que ainda não foram alcançados. [5]</p>
<h3 id="busca-primeiro-o-melhor">Busca primeiro o melhor</h3>
<p>É uma forma de escolher qual dos nós vai expandir, esta baseia-se em escolher o caminho que tem o menor custo possível, esse custo é determinado por uma função de avaliação; o resultado será uma indicação de falha ou um caminho para um nó alvo. [5]</p>
<h3 id="estruturas-de-dados-de-busca">Estruturas de dados de busca</h3>
<h4 id="nos">Nós</h4>
<p>Para armazenar os nós, uma estrutura de dados com quatro componentes é usada.</p>
<ul>
<li>node.STATE: o estado que corresponde ao nó. [5]</li>
<li>node.PARENT: o nó que gera o nó atual. [5]</li>
<li>node.ACTION: a ação que foi aplicada ao nó pai para gerar este nó. [5]</li>
<li>node.PATH-COST: o custo total do caminho do nó inicial ao atual. [5]</li>
</ul>
<h4 id="fronteira">Fronteira</h4>
<p>Para armazenar a fronteira é usada uma fila, as operações nessa fronteira são:</p>
<ul>
<li>IS-EMPTY(frontier): só retorna True quando não há nós na fronteira. [5]</li>
<li>POP(frontier): remove o nó superior da fronteira e apresenta-lo. [5]</li>
<li>TOP(frontier): apresenta, mas não elimina, o nó superior da fronteira. [5]</li>
<li>ADD(node, frontier): insere um nó na fronteira. [5]</li>
</ul>
<h4 id="tipos-de-filas">Tipos de filas</h4>
<ul>
<li>Fila de prioridade: o primeiro nó que usar a função POP será aquele com o custo mínimo determinado pela função de avaliação. [5]</li>
<li>Fila FIFO: o primeiro nó a ser usado pela função POP, será aquele que foi inserido primeiro na fila. [5]</li>
<li>Fila LIFO: o primeiro nó a ser usado pela função POP será aquele que foi inserido mais recentemente na fila. [5]</li>
</ul>
<h3 id="medir-el-rendimiento-en-la-resolucion-de-problemas">Medir el rendimiento en la resolución de problemas</h3>
<p>Critério utilizado para escolher algoritmos de busca, o desempenho pode ser medido em quatro formas:</p>
<ul>
<li>Completude: O algoritmo pode encontrar uma solução ou relatar sua falha quando não há uma? O algoritmo deve ser capaz, independentemente do tamanho do espaço, chegar a um estado que esteja conectado com o estado inicial. [5]</li>
<li>Otimização de custos: Pode encontrar uma solução com o menor custo de todas as soluções? [5] </li>
<li>Complexidade de tempo: Quanto tempo leva para encontrar uma solução. Pode ser medido em uma unidade de tempo como segundos ou pelo número de ações e estados. [5]</li>
<li>Complexidade do espaço: Quanta memória é usada para fazer a busca. [5]</li>
</ul>
<h2 id="busca-cega">Busca cega</h2>
<p>Algoritmos que não possuem informações sobre o espaço de busca, dependem unicamente da estrutura do espaço de busca para encontrar uma solução. [5] Eles são apenas capazes de gerar sucessores e diferenciar entre o estado objetivo e não-objetivo. Os planos para chegar ao estado-alvo a partir do estado inicial são diferenciados apenas pela ordem e duração das ações. [6]</p>
<h3 id="busca-por-amplitude">Busca por amplitude</h3>
<p>Estratégia apropriada quando todas as ações têm o mesmo custo, baseia-se em expandir primeiro todos os nós pai antes de expandir seus sucessores, começando com o nó raiz. É uma estratégia de busca sistemática, então funciona mesmo em espaços de estados infinitos. A função de avaliação é o número de ações que são tomadas para chegar a um nó. Para essa estratégia, uma fila FIFO é usada, onde os novos nós vão para o final da fila e os mais antigos ficam no início. Essa estratégia permite verificar se um estado é o alvo antes que ele saia da fila, porque uma vez que um estado foi atingido não será possível encontrar um caminho melhor. Busca por profundidade sempre encontra uma solução com o menor número de ações pois esta gera todos os nós em um "nível" antes de passar ao próximo pelo que se a solução estiver nesse "nível" já teria sido encontrada. Esta estratégia possui uma complexidade de tempo e espaço de O(b<sup>d</sup>) onde b são os nós sucessores e d é a profundidade da árvore de busca. [5]</p>
<p><img alt="BFS-DFS-common" src="../img/BFS_DFS_common_problem.PNG" /></p>
<p><em>Exemplo de problema a ser resolvido onde se deve ir de S para G.</em></p>
<p><img alt="BFS" src="../img/BFS_sol.PNG" /></p>
<p><em>Solução BFS para o problema.</em></p>
<h3 id="algoritmo-de-dijkstra">Algoritmo de Dijkstra</h3>
<p>Também conhecido como busca de custo uniforme é usado quando as ações têm custos diferentes, baseia-se em expandir primeiro o estado que tem o menor custo, esses custos são atribuídos com base no custo que têm todas as ações tomadas para chegar a esse estado. Se durante o processo for encontrado um caminho com menor custo para um estado que já havia sido alcançado, este caminho substituirá o anterior. A complexidade do algoritmo de Dijkstra é de O(b<sup>1 + [C<em>/e]</sup>) onde C</em> é o custo da solução ideal, e é o custo mínimo de uma ação com e &gt; 0 e b é o número de vizinhos por nó. Esta estratégia é completa e de custo ótimo, pois a primeira solução que encontrar terá um custo tão baixo quanto o custo de qualquer outro nó. [5]</p>
<p><img alt="dijkstra_problem" src="../img/djkstra_problem.PNG" /></p>
<p><em>Exemplo de problema a ser resolvido onde se deve ir de S para G.</em></p>
<p><img alt="dijkstra_sol" src="../img/djikstra_sol.PNG" /></p>
<p><em>Solução para o problema usando algoritmo dijkstra.</em></p>
<h3 id="busca-por-profundidade">Busca por profundidade</h3>
<p>Esta estratégia é baseada em expandir primeiro os nós sucessores antes de expandir os nós pai, nesta mente automaticamente "abaixa" tudo o que pode na árvore de busca até encontrar um nó que não tenha sucessores, Então, um nível é elevado e verifica se o nó pai tem outros nós sucessores não expandidos, se este for o caso, passa a expandir estes. Esta estratégia não é eficaz em custo, pois retorna a primeira solução que encontra. Somente é eficaz em espaços finitos que são árvores, em espaços cíclicos pode ficar presa em um loop infinito e em espaços infinitos é possível que termine presa em um caminho infinito mesmo não havendo ciclos, pelo que não é sistemática. Uma das suas principais vantagens e a principal razão pela qual é usado é a baixa quantidade de memória necessária. Sua complexidade espacial, somente em espaços onde é aplicável, é de O(bm) onde b é o fator de ramificação (número de filhos em cada nó) e m é a profundidade máxima da árvore. [5]</p>
<p><img alt="BFS-DFS-common" src="../img/BFS_DFS_common_problem.PNG" /></p>
<p><em>Exemplo de problema a ser resolvido onde se deve ir de S para G.</em></p>
<p><img alt="DFS" src="../img/DFS_sol.PNG" /></p>
<p><em>Solução DFS para o problema.</em></p>
<h3 id="busca-por-profundidade-limitada">Busca por profundidade limitada</h3>
<p>É uma versão de busca por profundidade na qual os nós que estão em uma profundidade l definida anteriormente, serão considerados como se não tivessem sucessores. Isso é feito com o objetivo de que a busca por profundidade não fique presa em um caminho infinito. A complexidade do espaço é O(b<sup>l</sup>) enquanto que a complexidade do tempo é O(bl) onde b é o fator de ramificação (número de filhos em cada nó) e l é a profundidade limite. Escolher o limite certo é muito importante, pois disso depende que o algoritmo possa alcançar a solução. Para aumentar a qualidade do limite definido pode-se usar informação que está disponível sobre o problema. Uma maneira bastante simples de definir esse limite é o número de nós na árvore menos um; no entanto, uma forma muito mais eficaz que é usar o diâmetro do grafo, este é o caminho mais curto entre os nós mais distantes no grafo. Infelizmente, na maioria dos casos, informações como o diâmetro não estarão disponíveis até que o problema seja resolvido. [5]</p>
<h3 id="busca-iterativa-de-aprofundamento">Busca iterativa de aprofundamento</h3>
<p>Versão do algoritmo usado como solução para o problema de encontrar um limite apropriado l, isso é feito executando o algoritmo usando cada valor possível, começando de zero, até que uma solução seja encontrada ou até que uma falha seja retornado. Seu uso é ótimo quando as ações custam o mesmo e é completo em espaços finitos sem ciclos ou quando os nós são verificados para ciclos ao longo do caminho. Os requisitos de memória não são tão altos sendo sua complexidade espacial O(bd) se houver solução ou O(bm) em espaços finitos onde não há. Isso é conseguido porque este algoritmo opta por gerar todos os nós novamente para cada iteração em vez de mantê-los na memória, no entanto, isto resulta em um aumento no tempo de execução. A complexidade do tempo é O(b<sup>d</sup>) quando há solução ou O(b<sup>m</sup>) quando não há. Para as complexidades b é o fator de ramificação (número de filhos em cada nó), m é a profundidade máxima (que aumenta em cada iteração) e d é a profundidade onde o alvo está. [5]</p>
<p><img alt="IDFS" src="../img/iterative_deep.PNG" /></p>
<p><em>Exemplo de algoritmo DFS iterativo.</em></p>
<h3 id="busca-bidirecional">Busca bidirecional</h3>
<p>Algoritmo no qual são feitas duas buscas ao mesmo tempo, uma do nó raiz e outra do nó alvo, isto com a intenção de que as duas buscas se encontrem para assim chegar à solução. Para que isso funcione corretamente é necessário manter duas tabelas de nós a que se chegou, duas fronteiras e ser capaz de raciocinar ao contrário (os papéis de nó pai e sucessor são invertidos quando vistos da perspectiva do outro busqueda). Para saber qual nó expandir usa a função de avaliação, expande o nó que tem o menor valor entre as duas fronteiras. A complexidade de tempo e espaço é O(b<sup>d/2</sup>) onde b é o fator de ramificação (número de filhos em cada nó) e d é a profundidade onde o alvo está. [5]</p>
<h2 id="exemplo-de-implementacao-de-busca-cega">Exemplo de implementação de busca cega</h2>
<p>Algoritmo que usa BFS bidirecional para resolver um problema de escada de palavras. Tenta converter uma palavra em outra. Neste exemplo, você só pode usar palavras que estão na lista e uma palavra só pode ser convertida em outra se a diferença for de uma letra.</p>
<pre><code class="language-python">
from collections import deque

def word_ladder_bidirectional_bfs(begin_word, end_word, word_list):

    if end_word not in word_list:
        return 0

    word_list = set(word_list)
    word_list.add(begin_word)

    begin_queue = deque([(begin_word, 1)])
    end_queue = deque([(end_word, 1)])

    begin_visited = {begin_word: 1}
    end_visited = {end_word: 1}

    while begin_queue and end_queue:
        result = bfs_step(begin_queue, begin_visited, end_visited, word_list)
        if result:
            return result

        result = bfs_step(end_queue, end_visited, begin_visited, word_list)
        if result:
            return result

    return 0

def bfs_step(queue, visited, other_visited, word_list):

    current_word, level = queue.popleft()

    for i in range(len(current_word)):
        for char in 'abcdefghijklmnopqrstuvwxyz':
            transformed_word = current_word[:i] + char + current_word[i+1:]

            if transformed_word in word_list:
                if transformed_word in other_visited:
                    return level + other_visited[transformed_word]

                if transformed_word not in visited:
                    visited[transformed_word] = level + 1
                    queue.append((transformed_word, level + 1))

    return None

if __name__ == &quot;__main__&quot;:

    word_list = [&quot;hot&quot;, &quot;dot&quot;, &quot;dog&quot;, &quot;lot&quot;, &quot;log&quot;, &quot;cog&quot;]

    print(&quot;Words in word list: &quot;)

    for word in word_list:
        print(word)

    begin_word = &quot;hit&quot;
    end_word = &quot;cog&quot;

    result = word_ladder_bidirectional_bfs(begin_word, end_word, word_list)

    if result:
        print(f&quot;The shortest transformation sequence length is: {result}&quot;)
    else:
        print(&quot;No valid transformation sequence exists.&quot;)

</code></pre>
<h2 id="busca-informada">Busca informada</h2>
<p>Algoritmos que têm informações no estado alvo que usam para aumentar a eficácia dos buscas. Esta informação vem na forma de heurísticas que são funções usadas para estimar a distância do estado alvo que ajudam a priorizar caminhos e não realizar explorações desnecessárias. Alguns exemplos de heuristicas são a distância de Manhattan e a distância euclidiana. Diferentes heurísticas são usadas dependendo do algoritmo que será implementado. [6]</p>
<h3 id="greedy-melhor-primeira-busca">Greedy melhor-primeira busca</h3>
<p>Uma forma de busca do melhor primeiro em que primeiro se expande o nó mais próximo ao alvo, esta distância pode ser expandida usando uma heurística h(x) expandindo o nó com o menor valor dado por essa heurística. Este algoritmo é completo em espaços finitos, mas não em espaços infinitos. Complexidade de espaço e tempo no mas dos casos é O(|V|), sem embrago com uma boa heurística a complexidade pode ser reduzida até O(bm) em certos problemas. Para escolher uma boa heurística é necessário ter uma quantidade de informações sobre o ambiente, qual heurística será usada depende do problema em questão. Um exemplo de heurística seria a distância da linha reta, que está relacionada à distância real dos caminhos. [5]</p>
<h3 id="busca-a">Busca A∗</h3>
<p>Estratégia que combina busca de custo uniforme e busca gananciosa, primeiro expande o nó que tem o menor valor f(n) que é calculado somando g(n), custo regressivo que é o custo do nó inicial até o nó atual n, com h(n), custo futuro que é o menor custo estimado do nó atual para o nó alvo. [6] A complexidade depende da heurística usada, no pior dos casos esta será igual à de busca de custo uniforme. A eficácia desta busca depende de que a heurística seja admissível, ou seja, não superestime o custo real de alcançar o nó alvo. Uma das principais desvantagens é o alto consumo de tempo e espaço de memória, pois muitos nós são expandidos. [5]</p>
<p><img alt="A_search_action_costs" src="../img/action_costs.PNG" /></p>
<p><em>Custo de chegar a cada nó para o exemplo de algoritmo de busca A∗.</em></p>
<p><img alt="A_search" src="../img/a_search.PNG" /></p>
<p><em>Exemplo de algoritmo de busca A∗.</em></p>
<h3 id="busca-a-ponderada">Busca A∗ ponderada</h3>
<p>Variação de busca A<em> em que se introduz um peso na fórmula f(n) ficando assim f(n) = g(n) + W</em>h(n), onde W seria o peso do nó, este sempre deve ser maior que um e seu valor aumentará quanto mais próximo este dito nó do nó alvo, Isso permite que o algoritmo explore os nós que podem ter um valor h(n) baixo. Este algoritmo só deve ser aplicado se você pode aceitar soluções subótimas, pois não garante o menor custo possível, em troca consome menos espaço e encontra uma solução em menos tempos porque expande menos nós. A complexidade é bastante semelhante à busca A* com várias variações. [8]</p>
<p><img alt="weighted_A_search" src="../img/weighted_a.PNG" /></p>
<p><em>Comparação de busca A∗ (a) com Busca A∗ ponderada (b). As barras cinzas são obstáculos, a linha roxa é o caminho do início verde até a meta vermelha, e os pequenos pontos são estados que foram alcançados por cada busca.</em></p>
<h3 id="busca-de-feixe">Busca de feixe</h3>
<p>Algoritmo de busca com funcionalidade similar à busca por profundidade, já que gera todos os sucessores em um nível, porém neste caso limitamos os nós que podem ser expandidos, só considerando aqueles que têm os melhores valores dados pela heurística. O número de nós que podem expandir é conhecido como a largura do raio (W) que é definida manualmente. Para saber quantos nós serão avaliados, multiplique-se a largura do feixe pelo fator de ramificação W * B. [9] Este algoritmo é incompleto e subótimo, pois não garante a solução com menos custo em troca de executar extremamente rápido e consumir muito menos memória porque expande menos nós. Na prática, ele é capaz de encontrar soluções muito próximas das ótimas para muitos problemas. Essa eficácia depende muito da qualidade da heurística. Complexidade do tempo é O(b<em>W) e complexidade do espaço é O(m</em>W*b) onde b é o fator de ramificação (número de filhos em cada nó), m é a profundidade máxima e W é a largura do raio. [5]</p>
<p><img alt="beam_search" src="../img/beam_search.PNG" /></p>
<p><em>Árvore de busca de feixe, com W = 2 e B = 3 - Apenas dois nós (nós pretos) são selecionados com base em seus valores heurísticos para expansão adicional em cada nível</em></p>
<h3 id="busca-a-com-aprofundamento-iterativo">Busca A∗ com aprofundamento iterativo</h3>
<p>Algoritmo que combina recursos de busca por profundidade iterativa com a busca A<em>. [10] Limita o uso de memória ao não salvar os nós visitados, isso faz com que eles sejam visitados novamente em cada iteração. [5] O número de nós expandidos depende do valor de f(n), isto é feito expandindo os nós até chegar a um com um valor f(n) maior que um limite definido, a iteração termina quando se chega a todos os nós com valores maiores que o limite. O valor limite aumenta a cada iteração. O valor f(n) é calculado g(n) + h(n). Este algoritmo garante encontrar a solução com o menor custo possível, além de também funciona em espaços infinitos tudo isso com um uso limitado de memória, em troca é mais lento que procura A</em> pois tem que percorrer todos os nós em cada iteração, até mesmo de exigir maior poder de processamento. [!0]</p>
<p><img alt="I_A_search_1" src="../img/IDA_1.PNG" /></p>
<p><em>Primeira iteração do algoritmo de busca A∗ com aprofundamento iterativa.</em></p>
<p><img alt="I_A_search_2" src="../img/IDA_2.PNG" /></p>
<p><em>Segunda iteração do algoritmo de busca A∗ com aprofundamento iterativa.</em></p>
<p><img alt="I_A_search_3" src="../img/IDA_3.PNG" /></p>
<p><em>Terceira iteração do algoritmo de busca A∗ com aprofundamento iterativa.</em></p>
<p><img alt="I_A_search_4" src="../img/IDA_4.PNG" /></p>
<p><em>Quarta iteração do algoritmo de busca A∗ com aprofundamento iterativa.</em></p>
<p><img alt="I_A_search_5" src="../img/IDA_5.PNG" /></p>
<p><em>Quinta iteração do algoritmo de busca A∗ com aprofundamento iterativa.</em></p>
<p><img alt="I_A_search_6" src="../img/IDA_6.PNG" /></p>
<p><em>Sexta iteração do algoritmo de busca A∗ com aprofundamento iterativa.</em></p>
<h3 id="busca-recursiva-do-melhor-primeiro">Busca recursiva do melhor primeiro</h3>
<p>Algoritmo com funcionalidade semelhante à busca do melhor primeiro, no entanto este tem a capacidade de "retroceder" se considerar que o caminho atual não é o melhor e existe uma alternativa que poderia dar melhores resultados. Isso é feito usando um valor f que serve como limite, se um nó atinge esse valor é retornado para seu antepassado, substitui o valor do limite pelo do nó e expande-se um nó alternativo que tenha o melhor valor f(n). Este algoritmo é ótimo se a heurística h(n) for admissível, ou seja, não superestime o custo real de alcançar o nó alvo. A complexidade espacial é linear à profundidade da solução com menor custo mais profunda, a complexidade de tempo varia muito, depende principalmente da precisão da função heurística e quantas vezes se muda de caminho. [5]</p>
<h3 id="pesquisa-heuristica-bidirecional">Pesquisa heurística bidirecional</h3>
<p>Algoritmo que implementa a funcionalidade de busca bidirecional com uma fórmula heurística para determinar qual nó será expandido entre as duas fronteiras. Uma maneira de fazer isso seria usando a fórmula de busca A<em> f (n) = g(n) + h(n), no entanto para que isso funcione a heurística dessa fórmula deve ser diferente para cada um dos dois busques que são feitos, porque ambos têm objetivos diferentes uma tenta ir para o objetivo e outra para a origem, por isso devem ser usadas duas fórmulas distintas fF(n) =gF(n) + hF(n) para busca que vai para o alvo e fB(n) = gB(n) + hB(n) para busca que vai para o nó raiz. Outra forma que pode ser feita é usando a fórmula f2(n) = max(2g(n),g(n)+h(n)), esta ao contrário da fórmula de busca A</em> pode ser usada para ambos os busses, expande-se o nó que tem o valor mínimo f2(n). Sua eficácia depende da qualidade da heurística, se essa heurística é boa busca A* dá melhores resultados, se a qualidade é regular procura bidirecional é preferida porque explora menos nós e se a heurística é má ambas têm um desempenho quase igual. Este algoritmo é completo e ótimo. [5]</p>
<h2 id="exemplo-de-implementacao-de-busca-informada">Exemplo de implementação de busca informada</h2>
<p>Algoritmo que usa beam search para encontrar os b (neste caso 3) melhores caminhos no grafo (caminhos com menor custo). Isto é, b é a largura do raio, assim como também é o valor limite. Para este exemplo, assume-se que todos os nós estão conectados a todos os outros nós. As posições na matriz são os nós e os números em cada posição é o custo de chegar a esse nó.</p>
<pre><code class="language-python">
from numpy import array


def beam_search(distances, beta):
    paths_so_far = [[list(), 0]]

    for idx, tier in enumerate(distances):
        if idx &gt; 0:
            print(f'Paths kept after tier {idx-1}:')
            print(*paths_so_far, sep='\n')
        paths_at_tier = list()

        for i in range(len(paths_so_far)):
            path, distance = paths_so_far[i]


            for j in range(len(tier)):
                path_extended = [path + [j], distance + tier[j]]
                paths_at_tier.append(path_extended)

        paths_ordered = sorted(paths_at_tier, key=lambda element: element[1])

        paths_so_far = paths_ordered[:beta]
        print(f'\nPaths pruned after tier {idx}: ')
        print(*paths_ordered[beta:], sep='\n')

    return paths_so_far


dists = [[1, 3, 2, 5, 8],
         [4, 7, 9, 6, 7]]
dists = array(dists)

best_beta_paths = beam_search(dists, 3)

print('\nThe best \'beta\' paths:')
for beta_path in best_beta_paths:
    print(beta_path)

</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.88dd0f4e.min.js"></script>
      
    
  </body>
</html>